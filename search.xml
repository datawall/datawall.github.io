<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Eureka IRule组件</title>
      <link href="/2019/06/24/Eureka-IRule%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/24/Eureka-IRule%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/gcxzflgl/article/details/82916262" target="_blank" rel="noopener">https://blog.csdn.net/gcxzflgl/article/details/82916262</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Consul或Zookeeper替换Euraka作为服务注册中心</title>
      <link href="/2019/06/24/%E4%BD%BF%E7%94%A8Consul%E6%88%96Zookeeper%E6%9B%BF%E6%8D%A2Euraka%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/06/24/%E4%BD%BF%E7%94%A8Consul%E6%88%96Zookeeper%E6%9B%BF%E6%8D%A2Euraka%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_37708181/article/details/80887689" target="_blank" rel="noopener">使用Consul或Zookeeper替换Euraka作为服务注册中心</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存调试工具</title>
      <link href="/2019/06/21/java%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/06/21/java%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#初步检查系统的情况下使用">初步检查系统的情况下使用</a><ul><li><a href="#jps">jps</a><ul><li><a href="#jps-l-查看java虚拟机的列表">jps -l  查看java虚拟机的列表</a></li></ul></li><li><a href="#jinfo">jinfo</a><ul><li><a href="#jinfo-pid-查看java虚拟机的参数配置">jinfo pid 查看java虚拟机的参数配置</a></li></ul></li><li><a href="#jstat">jstat</a><ul><li><a href="#jstat-gc-pid-5000-1000-查看gc情况和内存中类的信息">jstat <strong>-gc</strong> pid 5000 1000  查看gc情况和内存中类的信息</a></li><li><a href="#jstat-gcutil-pid-5000-1000">jstat <strong>-gcutil</strong> pid 5000 1000</a></li></ul></li><li><a href="#jmap">jmap</a><ul><li><a href="#jmap-f-dumpliveformatbfiletmpa-pid">jmap [-F] -dump:live,format=b,file=/tmp/a pid</a></li><li><a href="#jmap-f-histo-pid">jmap [-F] -histo pid</a></li><li><a href="#jmap-f-heap-pid">jmap [-F] heap pid</a></li></ul></li><li><a href="#jhat">jhat</a></li><li><a href="#jstack">jstack</a><ul><li><a href="#jstack-f-l-pid">jstack [-F] [-l] pid</a></li></ul></li></ul></li><li><a href="#外部工具">外部工具</a></li></ul><!-- tocstop --><h1><span id="初步检查系统的情况下使用">初步检查系统的情况下使用</span></h1><p>基本工具有：</p><h2><span id="jps">jps</span></h2><h3><span id="jps-l-查看java虚拟机的列表">jps -l  查看java虚拟机的列表</span></h3><h2><span id="jinfo">jinfo</span></h2><h3><span id="jinfo-pid-查看java虚拟机的参数配置">jinfo pid 查看java虚拟机的参数配置</span></h3><h2><span id="jstat">jstat</span></h2><h3><span id="jstat-gc-pid-5000-1000-查看gc情况和内存中类的信息">jstat <strong>-gc</strong> pid 5000 1000  查看gc情况和内存中类的信息</span></h3><p><img src="/images/pasted-85.png" alt="upload successful"></p><h3><span id="jstat-gcutil-pid-5000-1000">jstat <strong>-gcutil</strong> pid 5000 1000</span></h3><p>gcutil和gc差不多，只不过不是具体的内存数值，而是占比，内涵和gc类似  </p><h2><span id="jmap">jmap</span></h2><p>jmap（常用，看java堆情况，解决内存溢出）查看内存详细信息，<strong>可以dump到文件中</strong></p><h3><span id="jmap-f-dumpliveformatbfiletmpa-pid">jmap [-F] -dump:live,format=b,file=/tmp/a pid</span></h3><p><img src="/images/pasted-86.png" alt="upload successful"></p><h3><span id="jmap-f-histo-pid">jmap [-F] -histo pid</span></h3><p><img src="/images/pasted-87.png" alt="upload successful"></p><h3><span id="jmap-f-heap-pid">jmap [-F] heap pid</span></h3><p><img src="/images/pasted-88.png" alt="upload successful"></p><h2><span id="jhat">jhat</span></h2><p><img src="/images/pasted-89.png" alt="upload successful"></p><h2><span id="jstack">jstack</span></h2><p>jstack（常用，看线程池情况）</p><h3><span id="jstack-f-l-pid">jstack [-F] [-l] pid</span></h3><p>-l包含锁信息<br><img src="/images/pasted-90.png" alt="upload successful"></p><h1><span id="外部工具">外部工具</span></h1><p>jconsole<br>jvisualvm<br>mat</p><p>参考：<br><a href="https://blog.csdn.net/denganming1214/article/details/82692635" target="_blank" rel="noopener">java内存调试工具</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webclient使用代替RestTemplate</title>
      <link href="/2019/06/20/webclient%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/20/webclient%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>使用WebClient来调用远程REST服务，与RestTemplate相比，这个客户端具有更强的功能性，并且完全具有响应性。</p><h1><span id="添加pom文件">添加pom文件</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1><span id="webclient典型例子">WebClient典型例子</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    private final WebClient webClient;</span><br><span class="line"></span><br><span class="line">    public MyService(WebClient.Builder webClientBuilder) &#123;</span><br><span class="line">        this.webClient = webClientBuilder.baseUrl(&quot;http://example.org&quot;).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;Details&gt; someRestCall(String name) &#123;</span><br><span class="line">        return this.webClient.get().url(&quot;/&#123;name&#125;/details&quot;, name)</span><br><span class="line">                        .retrieve().bodyToMono(Details.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="webtestclient典型例子">WebTestClient典型例子</span></h1><p><img src="/images/pasted-84.png" alt="upload successful"></p><p>参考:<br><a href="https://www.cnblogs.com/NeverCtrl-C/p/9508313.html" target="_blank" rel="noopener">RestTemplate、WebClient</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>service中的构造器</title>
      <link href="/2019/06/20/service%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2019/06/20/service%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-83.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解监控方法时长</title>
      <link href="/2019/06/20/%E6%B3%A8%E8%A7%A3%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95%E6%97%B6%E9%95%BF/"/>
      <url>/2019/06/20/%E6%B3%A8%E8%A7%A3%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95%E6%97%B6%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#定义注解类">定义注解类</a></li><li><a href="#配置界面">配置界面</a></li><li><a href="#使用">使用</a></li></ul><!-- tocstop --><h1><span id="定义注解类">定义注解类</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.mdps.index.common.log;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface LogExecutionTime &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法名称，设置了就用这个</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="配置界面">配置界面</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.mdps.index.common.aspect;</span><br><span class="line"></span><br><span class="line">import com.mafengwo.mdps.index.common.log.LogExecutionTime;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: zhangqiang</span><br><span class="line"> * @date: 2019-04-22 16:34</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j(topic = &quot;monitor&quot;)</span><br><span class="line">public class ExecutionTimeAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;@annotation(com.mafengwo.mdps.index.common.log.LogExecutionTime)&quot;)</span><br><span class="line">    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            return joinPoint.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            long executionTime = System.currentTimeMillis() - start;</span><br><span class="line">            MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            String methodName = signature.getMethod().getName();</span><br><span class="line">            String annotationName = signature.getMethod().getAnnotation(LogExecutionTime.class).value();</span><br><span class="line">            String name = StringUtils.isBlank(annotationName) ? methodName : annotationName;</span><br><span class="line">            log.info(&quot;[&#123;&#125;]耗时&#123;&#125;ms&quot;, name, executionTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="使用">使用</span></h1><p><img src="/images/pasted-82.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试工具wrk</title>
      <link href="/2019/06/20/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7wrk/"/>
      <url>/2019/06/20/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7wrk/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java日期</title>
      <link href="/2019/06/20/java%E6%97%A5%E6%9C%9F/"/>
      <url>/2019/06/20/java%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wuqinghai2012/article/details/52996081" target="_blank" rel="noopener">java日期</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>插件</title>
      <link href="/2019/06/20/idea%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/06/20/idea%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2><span id="idea插件">idea插件   </span></h2><p>maven插件maven helper<br><img src="/images/pasted-81.png" alt="upload successful"> </p><p>格式化代码插件save actions  </p><h2><span id="chrome插件">chrome插件   </span></h2><p>vimium</p>]]></content>
      
      
      <categories>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java执行带管道的shell命令无返回值问题</title>
      <link href="/2019/06/14/java%E6%89%A7%E8%A1%8C%E5%B8%A6%E7%AE%A1%E9%81%93%E7%9A%84shell%E5%91%BD%E4%BB%A4%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/14/java%E6%89%A7%E8%A1%8C%E5%B8%A6%E7%AE%A1%E9%81%93%E7%9A%84shell%E5%91%BD%E4%BB%A4%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-80.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发执行</title>
      <link href="/2019/06/05/%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/06/05/%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#threadpoolfactory">ThreadPoolFactory</a></li><li><a href="#实战">实战</a></li></ul><!-- tocstop --><h1><span id="threadpoolfactory">ThreadPoolFactory</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.mdps.index.common.util;</span><br><span class="line"></span><br><span class="line">import com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: zhangqiang</span><br><span class="line"> * @date: 2019-05-07 19:53</span><br><span class="line"> */</span><br><span class="line">public class ThreadPoolFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static ExecutorService queryExecutor;</span><br><span class="line"></span><br><span class="line">    private static ExecutorService httpExecutor;</span><br><span class="line"></span><br><span class="line">    private static final int QUERY_POOL_SIZE = 200;</span><br><span class="line">    private static final long THREAD_KEEP_ALIVE_TIME = 60L;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;query-pool-%d&quot;).build();</span><br><span class="line">        ThreadFactory httpThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;http-pool-%d&quot;).build();</span><br><span class="line">        queryExecutor = new ThreadPoolExecutor(QUERY_POOL_SIZE, QUERY_POOL_SIZE,</span><br><span class="line">                THREAD_KEEP_ALIVE_TIME, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(), threadFactory);</span><br><span class="line">        httpExecutor = new ThreadPoolExecutor(QUERY_POOL_SIZE, QUERY_POOL_SIZE,</span><br><span class="line">                THREAD_KEEP_ALIVE_TIME, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(), httpThreadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ExecutorService getQueryExecutor() &#123;</span><br><span class="line">        return queryExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ExecutorService getHttpExecutor() &#123;</span><br><span class="line">        return httpExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="实战">实战</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean flag = new AtomicBoolean(false);</span><br><span class="line">        ExecutorService executorService = ThreadPoolFactory.getHttpExecutor();</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(queryRequest.getExtraData().size());</span><br><span class="line"></span><br><span class="line">        Map&lt;String,List&lt;Map&lt;String, ResultValue&gt;&gt;&gt; tempMap = Maps.newHashMap();</span><br><span class="line">        for (CompareCondWrapper wrapper : queryRequest.getExtraData()) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    List&lt;Map&lt;String, ResultValue&gt;&gt; res = getRes(queryRequest, queryStrategy, response, result, params, allFields, wrapper);</span><br><span class="line">                    tempMap.put(wrapper.toString(),res);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    flag.set(true);</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (flag.get()) &#123;</span><br><span class="line">            throw new BusinessException(&quot;处理ExtraData异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (CompareCondWrapper wrapper : queryRequest.getExtraData()) &#123;</span><br><span class="line">            result.add(tempMap.get(wrapper.toString()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Lombok来优雅的编码-java插件</title>
      <link href="/2019/06/03/springboot/"/>
      <url>/2019/06/03/springboot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qnight/p/8997493.html" target="_blank" rel="noopener">使用Lombok来优雅的编码</a></p><p><a href="https://blog.csdn.net/motui/article/details/79012846" target="_blank" rel="noopener">Lombok 介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pageHelper</title>
      <link href="/2019/05/28/pageHelper/"/>
      <url>/2019/05/28/pageHelper/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#pom">pom</a></li><li><a href="#pageentity">PageEntity</a></li><li><a href="#使用">使用</a></li></ul><!-- tocstop --><h1><span id="pom">pom</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1><span id="pageentity">PageEntity</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.hermes.taskmanager.entity.page;</span><br><span class="line"></span><br><span class="line">import com.github.pagehelper.Page;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * User: wangwang</span><br><span class="line"> * Date: 2019/4/23</span><br><span class="line"> * Time: 下午12:23</span><br><span class="line"> */</span><br><span class="line">public class PageEntity&lt;T&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前页</span><br><span class="line">     */</span><br><span class="line">    private int pageNum;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每页的数量</span><br><span class="line">     */</span><br><span class="line">    private int pageSize;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 总记录数</span><br><span class="line">     */</span><br><span class="line">    private long total;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 总页数</span><br><span class="line">     */</span><br><span class="line">    private int pages;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否为第一页</span><br><span class="line">     */</span><br><span class="line">    private boolean isFirstPage = false;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否为最后一页</span><br><span class="line">     */</span><br><span class="line">    private boolean isLastPage = false;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 结果集</span><br><span class="line">     */</span><br><span class="line">    private List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    public PageEntity() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 包装Page对象</span><br><span class="line">     *</span><br><span class="line">     * @param list</span><br><span class="line">     */</span><br><span class="line">    public PageEntity(List&lt;T&gt; list) &#123;</span><br><span class="line">        if (list instanceof Page) &#123;</span><br><span class="line">            Page page = (Page) list;</span><br><span class="line">            this.pageNum = page.getPageNum();</span><br><span class="line">            this.pageSize = page.getPageSize();</span><br><span class="line"></span><br><span class="line">            this.pages = page.getPages();</span><br><span class="line">            this.list = page;</span><br><span class="line">            this.total = page.getTotal();</span><br><span class="line">        &#125; else if (list instanceof Collection) &#123;</span><br><span class="line">            this.pageNum = 1;</span><br><span class="line">            this.pageSize = list.size();</span><br><span class="line">            this.pages = 1;</span><br><span class="line">            this.list = list;</span><br><span class="line">            this.total = list.size();</span><br><span class="line">        &#125;</span><br><span class="line">        if (list instanceof Collection) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 判断页面边界</span><br><span class="line">             */</span><br><span class="line">            judgePageBoudary();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判定页面边界</span><br><span class="line">     */</span><br><span class="line">    private void judgePageBoudary() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 当前也是否是第一页</span><br><span class="line">         */</span><br><span class="line">        isFirstPage = pageNum == 1;</span><br><span class="line">        /**</span><br><span class="line">         * 当前也是否是最后一页</span><br><span class="line">         */</span><br><span class="line">        isLastPage = pageNum == pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPageNum() &#123;</span><br><span class="line">        return pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageNum(int pageNum) &#123;</span><br><span class="line">        this.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFirstPage() &#123;</span><br><span class="line">        return isFirstPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirstPage(boolean firstPage) &#123;</span><br><span class="line">        isFirstPage = firstPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLastPage() &#123;</span><br><span class="line">        return isLastPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastPage(boolean lastPage) &#123;</span><br><span class="line">        isLastPage = lastPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPageSize() &#123;</span><br><span class="line">        return pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageSize(int pageSize) &#123;</span><br><span class="line">        this.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getTotal() &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotal(long total) &#123;</span><br><span class="line">        this.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPages() &#123;</span><br><span class="line">        return pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPages(int pages) &#123;</span><br><span class="line">        this.pages = pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;T&gt; List) &#123;</span><br><span class="line">        this.list = List;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PageEntity&#123;&quot; +</span><br><span class="line">                &quot;pageNum=&quot; + pageNum +</span><br><span class="line">                &quot;, pageSize=&quot; + pageSize +</span><br><span class="line">                &quot;, total=&quot; + total +</span><br><span class="line">                &quot;, pages=&quot; + pages +</span><br><span class="line">                &quot;, list=&quot; + list +</span><br><span class="line">                &quot;, isFirstPage=&quot; + isFirstPage +</span><br><span class="line">                &quot;, isLastPage=&quot; + isLastPage +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="使用">使用</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(task.getPageNum(), task.getPageSize());</span><br><span class="line">        PageEntity&lt;Task&gt; pageEntity = new PageEntity&lt;&gt;(taskMapper.findTaskByJob(task.getJobId()));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8_9</title>
      <link href="/2019/05/27/java8/"/>
      <url>/2019/05/27/java8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#java8">java8</a><ul><li><a href="#lambda-表达式-">Lambda 表达式 -&gt;</a></li><li><a href="#方法引用">方法引用 ::</a></li><li><a href="#函数式接口">函数式接口</a></li><li><a href="#接口的默认方法">接口的默认方法</a></li><li><a href="#stream">stream</a></li><li><a href="#optional-类">Optional 类</a></li><li><a href="#nashorn-javascript">Nashorn JavaScript</a></li><li><a href="#日期时间-api">日期时间 API</a></li><li><a href="#base64">Base64</a></li></ul></li><li><a href="#java9">java9</a><ul><li><a href="#try-with-resources">try-with-resources</a></li><li><a href="#集合工厂方法">集合工厂方法</a></li></ul></li></ul><!-- tocstop --><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">java8</a></p><h1><span id="java8">java8</span></h1><h2><span id="lambda-表达式-gt">Lambda 表达式 -&gt;</span></h2><p>操作符 -&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure></p><p>以下是lambda表达式的重要特征:</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><ol><li>Lambda 表达式主要用来定义行内执行的方法类型接口     </li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。  </li><li>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</li></ol><h2><span id="方法引用">方法引用 ::</span></h2><p>方法引用通过方法的名字来指向一个方法。<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>方法引用使用一对冒号 :: 。    </p><ol><li>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</li><li>静态方法引用：它的语法是Class::static_method</li><li>特定类的任意对象的方法引用：它的语法是Class::method</li><li>特定对象的方法引用：它的语法是instance::method</li></ol><p><img src="/images/pasted-79.png" alt="upload successful"></p><h2><span id="函数式接口">函数式接口</span></h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为 lambda 表达式。<br>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。   </p><h2><span id="接口的默认方法">接口的默认方法</span></h2><p>Java 8 新增了接口的默认方法。<br>简单说，<strong>默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。<br>我们只需在方法名前面加个 default 关键字即可实现默认方法</strong>。</p><blockquote><p>为什么要有这个特性？<br>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><h2><span id="stream">stream</span></h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。   </p><h2><span id="optional-类">Optional 类</span></h2><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。   </p><h2><span id="nashorn-javascript">Nashorn JavaScript</span></h2><h2><span id="日期时间-api">日期时间 API</span></h2><p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：<br>Local(本地) − 简化了日期时间的处理，没有时区的问题。<br>Zoned(时区) − 通过制定的时区处理日期时间。  </p><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p><h2><span id="base64">Base64</span></h2><p>在Java 8中，Base64编码已经成为Java类库的标准。</p><h1><span id="java9">java9</span></h1><p><a href="https://www.runoob.com/java/java9-new-features.html" target="_blank" rel="noopener">java9</a></p><h2><span id="try-with-resources">try-with-resources</span></h2><h2><span id="集合工厂方法">集合工厂方法</span></h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala</title>
      <link href="/2019/05/22/scala/"/>
      <url>/2019/05/22/scala/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/schwimmerxu/article/details/80967881" target="_blank" rel="noopener">json</a></p><p><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">scala</a></p><p>scala中list不能改变长度，listBuffer可以改变长度</p>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2019/05/21/kafka/"/>
      <url>/2019/05/21/kafka/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/litongtong1028/article/details/84896458" target="_blank" rel="noopener">kafkacat</a></p><p><a href="https://www.cnblogs.com/jun1019/p/6256139.html" target="_blank" rel="noopener">demo</a></p><p><a href="http://kafka.apache.org/quickstart" target="_blank" rel="noopener">kafka-quickstart</a></p><p><a href="https://kafka.apache.org/08/documentation.html" target="_blank" rel="noopener">kafka08</a></p><p><a href="https://cloud.tencent.com/developer/article/1340019" target="_blank" rel="noopener">kafka08 demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.kafka;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import kafka.javaapi.producer.Producer;</span><br><span class="line">import kafka.producer.KeyedMessage;</span><br><span class="line">import kafka.producer.ProducerConfig;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lifei</span><br><span class="line"> * Created in 2019-05-22</span><br><span class="line"> * Description</span><br><span class="line"> */</span><br><span class="line">public class MyProducer &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TOPIC = &quot;mobile&quot;; //kafka创建的topic</span><br><span class="line">    private static final String CONTENT = &quot;This is a single message&quot;; //要发送的内容</span><br><span class="line">    private static final String BROKER_LIST = &quot;127.0.0.1:9092&quot;; //broker的地址和端口</span><br><span class="line">    private static final String SERIALIZER_CLASS = &quot;kafka.serializer.StringEncoder&quot;; // 序列化类</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        props.put(&quot;metadata.broker.list&quot;, BROKER_LIST);</span><br><span class="line">        props.put(&quot;serializer.class&quot;, SERIALIZER_CLASS);</span><br><span class="line">        props.put(&quot;key.serializer.class&quot;, SERIALIZER_CLASS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ProducerConfig config = new ProducerConfig(props);</span><br><span class="line">        Producer&lt;String, String&gt; producer = new Producer&lt;String, String&gt;(config);</span><br><span class="line"></span><br><span class="line">        //Send one message.</span><br><span class="line">        KeyedMessage&lt;String, String&gt; message =</span><br><span class="line">                new KeyedMessage&lt;String, String&gt;(TOPIC, CONTENT);</span><br><span class="line">        producer.send(message);</span><br><span class="line">        producer.close();</span><br><span class="line"></span><br><span class="line">        //Send multiple messages.</span><br><span class="line">//        List&lt;KeyedMessage&lt;String,String&gt;&gt; messages =</span><br><span class="line">//                new ArrayList&lt;KeyedMessage&lt;String, String&gt;&gt;();</span><br><span class="line">//        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//            messages.add(new KeyedMessage&lt;String, String&gt;</span><br><span class="line">//                    (TOPIC, &quot;Multiple message at a time. &quot; + i));</span><br><span class="line">//        &#125;</span><br><span class="line">//        producer.send(messages);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink实例</title>
      <link href="/2019/05/21/flink%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/05/21/flink%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/huonan_123/article/details/84142539" target="_blank" rel="noopener">demo</a><br>nc -lk 9999<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.flinksql</span><br><span class="line"></span><br><span class="line">import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span><br><span class="line">import org.apache.flink.streaming.api.windowing.time.Time</span><br><span class="line">import org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line">object Test &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    // get the execution environment</span><br><span class="line">    val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    // get input data by connecting to the socket</span><br><span class="line">    val text = env.socketTextStream(&quot;localhost&quot;, 9999, &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    // parse the data, group it, window it, and aggregate the counts</span><br><span class="line">    val windowCounts = text</span><br><span class="line">      .flatMap &#123; w =&gt; w.split(&quot;\\s&quot;) &#125;</span><br><span class="line">      .map &#123; w =&gt; WordWithCount(w, 1) &#125;</span><br><span class="line">      .keyBy(&quot;word&quot;)</span><br><span class="line">      .timeWindow(Time.seconds(5), Time.seconds(1))</span><br><span class="line">      .sum(&quot;count&quot;)</span><br><span class="line"></span><br><span class="line">    // print the results with a single thread, rather than in parallel</span><br><span class="line">    windowCounts.print().setParallelism(1)</span><br><span class="line">    println(windowCounts)</span><br><span class="line">    env.execute(&quot;Socket Window WordCount&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  case class WordWithCount(word: String, count: Long)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flink学习</title>
      <link href="/2019/05/20/flink/"/>
      <url>/2019/05/20/flink/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">学习flink</a></p><p><a href="https://www.jianshu.com/p/27afa1b5ecf3" target="_blank" rel="noopener">RichFlatMapFunction</a></p><p><a href>RichFilterFunction</a></p><p><a href>RichCoFlatMapFunction</a></p>]]></content>
      
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀书籍</title>
      <link href="/2019/05/17/%E4%BC%98%E7%A7%80%E4%B9%A6%E7%B1%8D/"/>
      <url>/2019/05/17/%E4%BC%98%E7%A7%80%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<ol><li>图解设计模式   </li><li>程序员的数学  </li><li>数学女孩   </li><li>图解密码技术</li></ol>]]></content>
      
      
      <categories>
          
          <category> 优秀书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优秀书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid exactly-count</title>
      <link href="/2019/05/17/druid-exactly-count/"/>
      <url>/2019/05/17/druid-exactly-count/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/apache/incubator-druid/issues/6716" target="_blank" rel="noopener">exactly-count</a><br>对应不同的版本和分支<br><img src="/images/pasted-74.png" alt="upload successful"></p><p><img src="/images/pasted-75.png" alt="upload successful"></p><p><a href="https://mp.weixin.qq.com/s/jDW1sordtki-O5-tsVE94g" target="_blank" rel="noopener">博客</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC多版本并发控制</title>
      <link href="/2019/05/17/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/05/17/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/YFYkuner/p/5178684.html" target="_blank" rel="noopener">MVCC多版本并发控制</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之数tire</title>
      <link href="/2019/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0tire/"/>
      <url>/2019/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0tire/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000008877595?utm_source=tag-newest" target="_blank" rel="noopener">小白详解 Trie 树</a>  </p><p>Kylin 的 AppendTrie 树<br><a href="https://blog.csdn.net/johnny901114/article/details/80711441" target="_blank" rel="noopener">leetcode</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之分布式锁</title>
      <link href="/2019/05/10/redis%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/05/10/redis%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>分布式锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.qunar.marmot.etl.monitor.util;</span><br><span class="line"></span><br><span class="line">import com.qunar.redis.storage.Sedis2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by pan.xiong on 2017/8/14.</span><br><span class="line"> */</span><br><span class="line">public class DistributedLock &#123;</span><br><span class="line"></span><br><span class="line">    static Sedis2 sedis = SedisFactory.getSedis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static boolean lock(String key,String value,int second)&#123;</span><br><span class="line">        long result =sedis.setnx(key,value);</span><br><span class="line">        if (result == 1)&#123;</span><br><span class="line">            sedis.expire(key,second);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void unlock(String key)&#123;</span><br><span class="line">         sedis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guice之complex</title>
      <link href="/2019/05/09/guice%E4%B9%8Bcomplex/"/>
      <url>/2019/05/09/guice%E4%B9%8Bcomplex/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#父接口">父接口</a></li><li><a href="#普通实现">普通实现</a></li><li><a href="#注解实现">注解实现</a></li><li><a href="#module">module</a></li><li><a href="#test">Test</a></li></ul><!-- tocstop --><h1><span id="父接口">父接口</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line">import com.google.inject.ImplementedBy;</span><br><span class="line"></span><br><span class="line">//@ImplementedBy(TestInterfaceImpl.class)</span><br><span class="line">public interface TestInterface &#123;</span><br><span class="line">    String chargeOrder(String ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="普通实现">普通实现</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line">public class TestInterfaceImpl implements TestInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Test</span><br><span class="line">    public String chargeOrder(String ss) &#123;</span><br><span class="line">        return &quot;TestInterfaceImpl:&quot; + ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="注解实现">注解实现</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line">import com.google.inject.ImplementedBy;</span><br><span class="line"></span><br><span class="line">//@ImplementedBy(TestInterfaceImpl.class)</span><br><span class="line">public interface TestInterface &#123;</span><br><span class="line">    String chargeOrder(String ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestAnnotationImpl implements TestInterface &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String chargeOrder(String ss) &#123;</span><br><span class="line">        return &quot;TestAnnotationImpl:&quot; + ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="module">module</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line">import com.google.inject.AbstractModule;</span><br><span class="line">import com.google.inject.Scopes;</span><br><span class="line"></span><br><span class="line">public class TestModule extends AbstractModule &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure() &#123;</span><br><span class="line">        //标识  @Test注解是和TestAnnotationImpl一起的</span><br><span class="line">        bind(TestInterface.class)</span><br><span class="line">                .annotatedWith(Test.class)</span><br><span class="line">                .to(TestAnnotationImpl.class)</span><br><span class="line">                .in(Scopes.SINGLETON);</span><br><span class="line"></span><br><span class="line">        bind(TestInterface.class).to(TestInterfaceImpl.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="test">Test</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.complex;</span><br><span class="line"></span><br><span class="line">import com.example.demo.guice.simple.BillingModule;</span><br><span class="line">import com.example.demo.guice.simple.BillingService;</span><br><span class="line">import com.google.inject.Guice;</span><br><span class="line">import com.google.inject.Inject;</span><br><span class="line">import com.google.inject.Injector;</span><br><span class="line">import com.google.inject.Key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * http://www.blogjava.net/xylz/category/43238.html</span><br><span class="line"> */</span><br><span class="line">public class TestMain &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    private TestInterface testInterface;</span><br><span class="line"></span><br><span class="line">    public TestInterface getTestInterface() &#123;</span><br><span class="line">        return testInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Test</span><br><span class="line">    private TestInterface testAnnotationInterface;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    private TestInterface noAnnotationInterface;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Injector injector = Guice.createInjector(new TestModule());</span><br><span class="line">        //有test注解，TestAnnotationImpl-注解类</span><br><span class="line">        TestInterface annotationInterface = injector.getInstance(Key.get(TestInterface.class, Test.class));</span><br><span class="line">        System.out.println(annotationInterface.chargeOrder(&quot;666&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //没有test注解找到TestInterfaceImpl-普通类</span><br><span class="line">        TestInterface instance = injector.getInstance(TestInterface.class);</span><br><span class="line">        System.out.println(instance.chargeOrder(&quot;haha&quot;));</span><br><span class="line"></span><br><span class="line">        //依赖于TestInterface配置@ImplementedBy(TestInterfaceImpl.class)</span><br><span class="line">        //参考：http://www.blogjava.net/xylz/archive/2009/xylz/archive/2009/12/23/307092.html</span><br><span class="line"></span><br><span class="line">        TestMain t = injector.getInstance(TestMain.class);</span><br><span class="line">        System.out.println(t.getTestInterface().chargeOrder(&quot;我是谁11&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(t.testAnnotationInterface.chargeOrder(&quot;我是谁22&quot;));</span><br><span class="line">        System.out.println(t.noAnnotationInterface.chargeOrder(&quot;我是谁33&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> guice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guice之simple</title>
      <link href="/2019/05/09/guice%E4%B9%8Bsimple/"/>
      <url>/2019/05/09/guice%E4%B9%8Bsimple/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#maven">maven</a></li><li><a href="#父接口">父接口</a></li><li><a href="#子实现">子实现</a></li><li><a href="#module绑定父子">module绑定父子</a></li><li><a href="#使用">使用</a></li></ul><!-- tocstop --><h1><span id="maven">maven</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1><span id="父接口">父接口</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.simple;</span><br><span class="line"></span><br><span class="line">public interface BillingService &#123;</span><br><span class="line">    String chargeOrder(String ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="子实现">子实现</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.simple;</span><br><span class="line"></span><br><span class="line">public class RealBillingService implements BillingService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String chargeOrder(String ss) &#123;</span><br><span class="line">        return &quot;realBill:&quot; + ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="module绑定父子">module绑定父子</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.simple;</span><br><span class="line"></span><br><span class="line">import com.google.inject.AbstractModule;</span><br><span class="line"></span><br><span class="line">public class BillingModule extends AbstractModule &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 父-子</span><br><span class="line">         */</span><br><span class="line">        bind(BillingService.class).to(RealBillingService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="使用">使用</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.guice.simple;</span><br><span class="line"></span><br><span class="line">import com.google.inject.Guice;</span><br><span class="line">import com.google.inject.Injector;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Injector injector = Guice.createInjector(new BillingModule());</span><br><span class="line">        //BillingService.clss是接口</span><br><span class="line">        BillingService instance = injector.getInstance(BillingService.class);</span><br><span class="line">        System.out.println(instance.chargeOrder(&quot;haha&quot;));</span><br><span class="line">        //每次getInstance不是单例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> guice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>airline-解析命令行</title>
      <link href="/2019/05/09/airline/"/>
      <url>/2019/05/09/airline/</url>
      
        <content type="html"><![CDATA[<h1><span id="simple-demo">simple demo</span></h1><h2><span id="doctorq">Doctorq</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.airline;</span><br><span class="line"></span><br><span class="line">import com.github.rvesse.airline.annotations.Arguments;</span><br><span class="line">import com.github.rvesse.airline.annotations.Command;</span><br><span class="line"></span><br><span class="line">@Command(name = &quot;doctorq&quot;, description = &quot;test for cli&quot;)</span><br><span class="line">public class Doctorq implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Arguments</span><br><span class="line">    private String company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;company 等于 &quot; + company);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="test">test</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.airline;</span><br><span class="line"></span><br><span class="line">import com.github.rvesse.airline.Cli;</span><br><span class="line">import com.github.rvesse.airline.builder.CliBuilder;</span><br><span class="line">import com.github.rvesse.airline.help.Help;</span><br><span class="line">import com.github.rvesse.airline.parser.errors.ParseArgumentsUnexpectedException;</span><br><span class="line"></span><br><span class="line">public class HarCliTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CliBuilder&lt;Runnable&gt; builder = Cli.&lt;Runnable&gt;builder(&quot;har&quot;)</span><br><span class="line">                .withDescription(&quot;HAR power tool&quot;)</span><br><span class="line">                .withDefaultCommand(Help.class)</span><br><span class="line">                .withCommands(Help.class, Doctorq.class);</span><br><span class="line"></span><br><span class="line">        Cli&lt;Runnable&gt; cliParser = builder.build();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            cliParser.parse(args).run();</span><br><span class="line">        &#125; catch (ParseArgumentsUnexpectedException e) &#123;</span><br><span class="line">            System.out.println(&quot;Invalid command, use &apos;$ har help&apos; for usage instructions!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-73.png" alt="upload successful"><br>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">company 等于 haha</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"># group demo</span><br><span class="line">## cmd</span><br></pre></td></tr></table></figure></p><p>package com.example.demo.airline.group;</p><p>import com.github.rvesse.airline.annotations.Arguments;<br>import com.github.rvesse.airline.annotations.Command;<br>import com.github.rvesse.airline.annotations.Option;</p><p>@Command(name = “cmd1”, description = “This is Command1”)<br>public class Command1 implements Runnable {</p><pre><code>@Argumentsprivate String command;@Option(name = {&quot;-s&quot;, &quot;--server&quot;},        title = &quot;server&quot;,        description = &quot;Presto server location (default: localhost:8080)&quot;)public String server = &quot;localhost:8080&quot;;@Overridepublic void run() {    System.out.println(&quot;cmd1=&quot; + command + &quot;,server:&quot; + server);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## cmd1_2</span><br></pre></td></tr></table></figure></p><p>package com.example.demo.airline.group;</p><p>import com.github.rvesse.airline.annotations.Arguments;<br>import com.github.rvesse.airline.annotations.Command;</p><p>@Command(name = “cmd1_2”, description = “This is Command1_2”)<br>public class Command1_2 implements Runnable {</p><pre><code>@Argumentsprivate String command;@Overridepublic void run() {    System.out.println(&quot;cmd1_2=&quot; + command);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd1,cmd1_2同属于一个组  </span><br><span class="line">## cmd2</span><br></pre></td></tr></table></figure><p>package com.example.demo.airline.group;</p><p>import com.github.rvesse.airline.annotations.Arguments;<br>import com.github.rvesse.airline.annotations.Command;</p><p>@Command(name = “cmd2”, description = “This is Command2”)<br>public class Command2 implements Runnable {</p><pre><code>@Argumentsprivate String command;@Overridepublic void run() {    System.out.println(&quot;cmd2=&quot; + command);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd2自己一个组</span><br><span class="line">## MainTest</span><br></pre></td></tr></table></figure></p><p>package com.example.demo.airline.group;</p><p>import com.github.rvesse.airline.Cli;<br>import com.github.rvesse.airline.builder.CliBuilder;<br>import com.github.rvesse.airline.help.Help;<br>import com.github.rvesse.airline.parser.errors.ParseArgumentsUnexpectedException;</p><p>import java.util.Arrays;</p><p>public class MainTest {</p><pre><code>public static void main(String[] args) {    args = new String[4];    args[0] = &quot;g1&quot;;//group名    args[1] = &quot;cmd1&quot;;    args[2] = &quot;123&quot;;    args[3] = &quot;-s haha:8888&quot;;</code></pre><p>//        cmd1=123</p><p>//        args[0] = “g1”;//group名<br>//        args[1] = “cmd1_2”;//todo cmd1_2<br>//        args[2] = “123”;<br>//        cmd1_2=123</p><p>//        args[0] = “g2”;//group名<br>//        args[1] = “cmd2”;//todo cmd2<br>//        args[2] = “123”;<br>//        cmd2=123</p><pre><code>    //什么都不传报错，如果只传一个值g1/g2会提示；这个功能应该是Help.class实现的    System.out.println(&quot;===&gt; &quot; + Arrays.asList(args));    CliBuilder&lt;Runnable&gt; builder = Cli.&lt;Runnable&gt;builder(&quot;MyCMD&quot;);    builder.withGroup(&quot;g1&quot;)            .withDescription(&quot;g1:Description&quot;)            .withDefaultCommand(Help.class)            .withCommands(Help.class, Command1.class, Command1_2.class);    builder.withGroup(&quot;g2&quot;)            .withDescription(&quot;g2:Description&quot;)            .withDefaultCommand(Help.class)            .withCommands(Help.class, Command2.class);    Cli&lt;Runnable&gt; cliParser = builder.build();    try {        cliParser.parse(args).run();    } catch (ParseArgumentsUnexpectedException e) {        System.out.println(&quot;Invalid command:&quot; + e.toString());    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maven</span><br></pre></td></tr></table></figure></p><p><dependency><br>            <groupid>com.github.rvesse</groupid><br>            <artifactid>airline-examples</artifactid><br>            <version>2.6.0</version><br></dependency><br><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> airline </category>
          
      </categories>
      
      
        <tags>
            
            <tag> airline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之EasyMock</title>
      <link href="/2019/05/09/springboot%E4%B9%8BeasyMock/"/>
      <url>/2019/05/09/springboot%E4%B9%8BeasyMock/</url>
      
        <content type="html"><![CDATA[<p>模拟测试</p><h1><span id="定义服务接口">定义服务接口</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.easymock;</span><br><span class="line"></span><br><span class="line">public interface CalculatorService &#123;</span><br><span class="line">    public double add(double input1, double input2);</span><br><span class="line"></span><br><span class="line">    public double subtract(double input1, double input2);</span><br><span class="line"></span><br><span class="line">    public double multiply(double input1, double input2);</span><br><span class="line"></span><br><span class="line">    public double divide(double input1, double input2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="定义应用">定义应用</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.easymock;</span><br><span class="line"></span><br><span class="line">public class MathApplication &#123;</span><br><span class="line">    private CalculatorService calcService;</span><br><span class="line"></span><br><span class="line">    public void setCalculatorService(CalculatorService calcService) &#123;</span><br><span class="line">        this.calcService = calcService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double add(double input1, double input2) &#123;</span><br><span class="line">        return calcService.add(input1, input2) + 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double subtract(double input1, double input2) &#123;</span><br><span class="line">        return calcService.subtract(input1, input2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double multiply(double input1, double input2) &#123;</span><br><span class="line">        return calcService.multiply(input1, input2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double divide(double input1, double input2) &#123;</span><br><span class="line">        return calcService.divide(input1, input2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="测试">测试</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.easymock;</span><br><span class="line"></span><br><span class="line">import org.easymock.EasyMock;</span><br><span class="line"></span><br><span class="line">public class TestEasymock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CalculatorService calcService = EasyMock.createMock(CalculatorService.class);</span><br><span class="line">        MathApplication mathApplication = new MathApplication();</span><br><span class="line">        mathApplication.setCalculatorService(calcService);</span><br><span class="line"></span><br><span class="line">        EasyMock.expect(calcService.add(10.0, 20.0)).andReturn(30.00);</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(calcService);</span><br><span class="line"></span><br><span class="line">        System.out.println(mathApplication.add(10.0, 20.0));</span><br><span class="line">        EasyMock.verify(calcService);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果返回：130<br>EasyMock.replay() 不会实际重放 mock。而是重新设置 mock，在下一次调用它的方法时，它将开始重放。   </p><p>参考：<br><a href="https://www.yiibai.com/easymock/easymock_example_with_verify.html" target="_blank" rel="noopener">教程</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot之格式转换</title>
      <link href="/2019/05/09/springboot%E4%B9%8B%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/05/09/springboot%E4%B9%8B%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>格式转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebPageConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    //消息格式转换</span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        //1.需要定义一个convert转换消息的对象;</span><br><span class="line">        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();</span><br><span class="line">        //2.添加fastJson的配置信息，比如：是否要格式化返回的json数据;</span><br><span class="line">        FastJsonConfig fastJsonConfig = new FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat,</span><br><span class="line">                SerializerFeature.WriteMapNullValue,</span><br><span class="line">                SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">                SerializerFeature.DisableCircularReferenceDetect,</span><br><span class="line">                SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">                SerializerFeature.WriteDateUseDateFormat);</span><br><span class="line">        //3处理中文乱码问题</span><br><span class="line">        List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;();</span><br><span class="line">        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">        //4.在convert中添加配置信息.</span><br><span class="line">        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);</span><br><span class="line">        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        //5.将convert添加到converters当中.</span><br><span class="line">        converters.add(fastJsonHttpMessageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之注解RestTemplate</title>
      <link href="/2019/05/09/springboot%E4%B9%8B%E6%B3%A8%E8%A7%A3RestTemplate/"/>
      <url>/2019/05/09/springboot%E4%B9%8B%E6%B3%A8%E8%A7%A3RestTemplate/</url>
      
        <content type="html"><![CDATA[<p>注解RestTemplate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RestfulTemplateConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之批量异步调用</title>
      <link href="/2019/05/09/springboot%E4%B9%8B%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
      <url>/2019/05/09/springboot%E4%B9%8B%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>批量调用，统一返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">    private MasterOfOverLordAndCoordinator masterOfOverLordAndCoordinator;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public Future&lt;Object&gt; getFuture(String taskType) &#123;</span><br><span class="line">        MasterNode masterNode = new MasterNode();</span><br><span class="line">        masterNode.setNodeType(&quot;overlord&quot;);</span><br><span class="line">        ResponseObject&lt;MasterNode&gt; masterOfOverlordOrCoordinator</span><br><span class="line">                = masterOfOverLordAndCoordinator.getMasterOfOverlordOrCoordinator(masterNode);</span><br><span class="line">        MasterNode node = masterOfOverlordOrCoordinator.getData();</span><br><span class="line">        node.setNodeApi(&quot;druid/indexer/v1/&quot;+taskType);</span><br><span class="line"></span><br><span class="line">        TemplateParams templateParams = new TemplateParams();</span><br><span class="line">        templateParams.setRestTemplate(restTemplate);</span><br><span class="line">        templateParams.setType(GET);</span><br><span class="line">        templateParams.setUrl(node.getUrl());</span><br><span class="line">        return new AsyncResult&lt;&gt;(TemplateUtils.restTemplateGetAndPostObject(templateParams));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getTaskList(String logsource)&#123;</span><br><span class="line">        Map&lt;String, List&lt;MonitorInfomation&gt;&gt; res = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; taskMap = Maps.newHashMap();</span><br><span class="line">        List&lt;String&gt; tasks = Lists.newArrayList(&quot;completeTasks&quot;, &quot;runningTasks&quot;, &quot;waitingTasks&quot;,&quot;pendingTasks&quot;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Future&lt;Object&gt;&gt; jobFutureMap = Maps.newHashMap();</span><br><span class="line">        for (String tt : tasks) &#123;</span><br><span class="line">            Future&lt;Object&gt; da = getFuture(tt);</span><br><span class="line">            jobFutureMap.put(tt, da);</span><br><span class="line">        &#125;</span><br><span class="line">        for (String tt : jobFutureMap.keySet()) &#123;</span><br><span class="line">            Future&lt;Object&gt; future = jobFutureMap.get(tt);</span><br><span class="line">            try &#123;</span><br><span class="line">                taskMap.put(tt, future.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MonitorInfomation&gt; successTasks = Lists.newArrayList();</span><br><span class="line">        List&lt;MonitorInfomation&gt; failedTasks = Lists.newArrayList();</span><br><span class="line">        for (String taskType:taskMap.keySet()) &#123;</span><br><span class="line">            ArrayList jsonArray = (ArrayList) taskMap.get(taskType);</span><br><span class="line">            List&lt;MonitorInfomation&gt; list = Lists.newArrayList();</span><br><span class="line">            MonitorInfomation mi;</span><br><span class="line">            if (jsonArray.size() != 0)&#123;</span><br><span class="line">                for (Object o:jsonArray) &#123;</span><br><span class="line">                    LinkedHashMap js = (LinkedHashMap) o;</span><br><span class="line">                    if (String.valueOf(js.get(&quot;id&quot;)).contains(logsource))&#123;</span><br><span class="line">                        mi = new MonitorInfomation();</span><br><span class="line">                        mi.setTaskName(String.valueOf(js.get(&quot;id&quot;)));</span><br><span class="line">                        mi.setTaskType(taskType);</span><br><span class="line">                        mi.setDuration(String.valueOf(js.get(&quot;duration&quot;)));</span><br><span class="line">                        mi.setCreatedTime(String.valueOf(js.get(&quot;createdTime&quot;)));</span><br><span class="line">                        if (taskType.equals(&quot;completeTasks&quot;))&#123;</span><br><span class="line">                            if (String.valueOf(js.get(&quot;duration&quot;)).equals(&quot;-1&quot;))&#123;</span><br><span class="line">                                mi.setTaskType(&quot;failedTasks&quot;);</span><br><span class="line">                                failedTasks.add(mi);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                mi.setTaskType(&quot;successTasks&quot;);</span><br><span class="line">                                successTasks.add(mi);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            list.add(mi);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!taskType.equals(&quot;completeTasks&quot;))&#123;</span><br><span class="line">                res.put(taskType,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.put(&quot;failedTasks&quot;,failedTasks);</span><br><span class="line">        res.put(&quot;successTasks&quot;,successTasks);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之整合quartz</title>
      <link href="/2019/05/09/springboot%E4%B9%8B%E6%95%B4%E5%90%88quartz/"/>
      <url>/2019/05/09/springboot%E4%B9%8B%E6%95%B4%E5%90%88quartz/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#解决问题">解决问题</a><ul><li><a href="#架构">架构</a></li></ul></li><li><a href="#maven">maven</a></li><li><a href="#建表">建表</a></li><li><a href="#applicationyml">application.yml</a></li><li><a href="#扩展schedulerfactorybean">扩展SchedulerFactoryBean</a></li><li><a href="#schedulemanager">ScheduleManager</a></li><li><a href="#taskjob">TaskJob</a></li><li><a href="#添加定时任务service">添加定时任务service</a></li><li><a href="#controller">controller</a></li><li><a href="#如果有默认定时不提倡">如果有默认定时，不提倡</a></li></ul><!-- tocstop --><h1><span id="解决问题">解决问题</span></h1><ol><li>单机部署问题：单机模式下的定时任务调用很简单，有很多可实现的方案，这里不多说了，例如spring schedule，java timer等</li><li><p>集群部署重复创建实例问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在有 A ， B ， C  3 台机器同时作为集群服务器对外统一提供 SERVICE ：</span><br><span class="line"></span><br><span class="line">A ， B ， C   3 台机器上各有一个 QUARTZ  Job，它们会按照即定的 SCHEDULE 自动执行各自的任务。</span><br><span class="line"></span><br><span class="line">先不说实现什么功能，这样的架构有点像多线程。由于三台SERVER 里都有 QUARTZ ，因此会存在重复处理 TASK 的现象。</span><br><span class="line"></span><br><span class="line">一般外面的解决方案是只在一台 服务器上装 QUARTZ ，其它两台不装，这样的话其实就是单机了，quartz存在单点问题，一旦装有quartz的服务器宕了。服务就无法提供了。</span><br></pre></td></tr></table></figure></li><li><p>quartz本身提供了很好的集群方案。下面我们来说一下在spring boot下的集成：quartz集群需要数据库的支持（JobStore TX或者JobStoreCMT），<strong>从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作的</strong>   </p></li></ol><h2><span id="架构">架构</span></h2><p><img src="/images/pasted-72.png" alt="upload successful"></p><h1><span id="maven">maven</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1><span id="建表">建表</span></h1><h1><span id="applicationyml">application.yml</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  quartz:</span><br><span class="line">    job-store-type: jdbc #数据库方式</span><br><span class="line">    jdbc:</span><br><span class="line">      initialize-schema: never #不初始化表结构</span><br><span class="line">    properties:</span><br><span class="line">      org:</span><br><span class="line">        quartz:</span><br><span class="line">          scheduler:</span><br><span class="line">            instanceId: AUTO #默认主机名和时间戳生成实例ID,可以是任何字符串，但对于所有调度程序来说，必须是唯一的 对应qrtz_scheduler_state INSTANCE_NAME字段</span><br><span class="line">            #instanceName: clusteredScheduler #quartzScheduler</span><br><span class="line">          jobStore:</span><br><span class="line">            class: org.quartz.impl.jdbcjobstore.JobStoreTX #持久化配置</span><br><span class="line">            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate #我们仅为数据库制作了特定于数据库的代理</span><br><span class="line">            useProperties: true #以指示JDBCJobStore将JobDataMaps中的所有值都作为字符串，因此可以作为名称 - 值对存储而不是在BLOB列中以其序列化形式存储更多复杂的对象。从长远来看，这是更安全的，因为您避免了将非String类序列化为BLOB的类版本问题。</span><br><span class="line">            tablePrefix: QRTZ_  #数据库表前缀</span><br><span class="line">            misfireThreshold: 60000 #在被认为“失火”之前，调度程序将“容忍”一个Triggers将其下一个启动时间通过的毫秒数。默认值（如果您在配置中未输入此属性）为60000（60秒）。</span><br><span class="line">            clusterCheckinInterval: 5000 #设置此实例“检入”*与群集的其他实例的频率（以毫秒为单位）。影响检测失败实例的速度。</span><br><span class="line">            isClustered: true #打开群集功能</span><br><span class="line">          threadPool: #连接池</span><br><span class="line">            class: org.quartz.simpl.SimpleThreadPool</span><br><span class="line">            threadCount: 10</span><br><span class="line">            threadPriority: 5</span><br><span class="line">            threadsInheritContextClassLoaderOfInitializingThread: true</span><br></pre></td></tr></table></figure><p>由于指定了<code>useProperties=true</code>,所以JobDataMaps中的所有值都作为字符串。</p><h1><span id="扩展schedulerfactorybean">扩展SchedulerFactoryBean</span></h1><p>SpringBoot的QuartzAutoConfiguration类会帮我自动配置SchedulerFactoryBean。使用SpringBoot提供的SchedulerFactoryBeanCustomizer接口去扩展SchedulerFactoryBean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.hermes.taskmanager.schedule;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.quartz.SchedulerFactoryBeanCustomizer;</span><br><span class="line">import org.springframework.scheduling.quartz.SchedulerFactoryBean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lifei</span><br><span class="line"> * Created in 2019-05-08</span><br><span class="line"> * Description</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class MySchedulerFactoryBean implements SchedulerFactoryBeanCustomizer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(SchedulerFactoryBean schedulerFactoryBean) &#123;</span><br><span class="line">        schedulerFactoryBean.setOverwriteExistingJobs(true);//更新trigger的 表达式时，同步数据到数据库qrtz_cron_triggers表 开启</span><br><span class="line">        schedulerFactoryBean.setApplicationContextSchedulerContextKey(&quot;applicationContext&quot;);//注入applicationContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="schedulemanager">ScheduleManager</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.hermes.taskmanager.schedule;</span><br><span class="line"></span><br><span class="line">import org.quartz.*;</span><br><span class="line">import org.springframework.scheduling.quartz.SchedulerFactoryBean;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ScheduleManager &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    SchedulerFactoryBean mySchedulerFactory;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * @Description: 添加一个定时任务 </span><br><span class="line">     *  </span><br><span class="line">     * @param jobName 任务名 </span><br><span class="line">     * @param jobGroupName  任务组名 </span><br><span class="line">     * @param jobClass  任务</span><br><span class="line">     * @param cron   时间设置，参考quartz说明文档  </span><br><span class="line">     */  </span><br><span class="line">    @Transactional</span><br><span class="line">    public void addJob(String jobName, String jobGroupName,Class jobClass, String cron,JobDataMap jobDataMap) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">            // 任务名，任务组，任务执行类</span><br><span class="line">            JobDetail jobDetail= JobBuilder.newJob(jobClass).withIdentity(jobName, jobGroupName).setJobData(jobDataMap).build();</span><br><span class="line">            // 触发器  </span><br><span class="line">            TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();</span><br><span class="line">            // 触发器名,触发器组  </span><br><span class="line">            triggerBuilder.withIdentity(jobName, jobGroupName);</span><br><span class="line">            triggerBuilder.startNow();</span><br><span class="line">            // 触发器时间设定  </span><br><span class="line">            triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron).withMisfireHandlingInstructionDoNothing());</span><br><span class="line">            // 创建Trigger对象</span><br><span class="line">            CronTrigger trigger = (CronTrigger) triggerBuilder.build();</span><br><span class="line"></span><br><span class="line">            // 调度容器设置JobDetail和Trigger</span><br><span class="line">            sched.scheduleJob(jobDetail, trigger);  </span><br><span class="line"></span><br><span class="line">            // 启动  </span><br><span class="line">            if (!sched.isShutdown()) &#123;  </span><br><span class="line">                sched.start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (SchedulerException e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * @Description: 修改一个任务的触发时间</span><br><span class="line">     *  </span><br><span class="line">     * @param jobName </span><br><span class="line">     * @param jobGroupName</span><br><span class="line">     * @param cron   时间设置，参考quartz说明文档</span><br><span class="line">     */  </span><br><span class="line">    public void modifyJobTime(String jobName, </span><br><span class="line">            String jobGroupName, String cron,JobDataMap jobDataMap) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);</span><br><span class="line">            CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);  </span><br><span class="line">            if (trigger == null) &#123;  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            String oldTime = trigger.getCronExpression();  </span><br><span class="line">            if (!oldTime.equalsIgnoreCase(cron)) &#123; </span><br><span class="line">                /** 方式二：先删除，然后在创建一个新的Job  */</span><br><span class="line">                JobDetail jobDetail = sched.getJobDetail(JobKey.jobKey(jobName, jobGroupName));  </span><br><span class="line">                Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass();  </span><br><span class="line">                removeJob(jobName, jobGroupName);  </span><br><span class="line">                addJob(jobName, jobGroupName,jobClass, cron,jobDataMap); </span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * @Description: 移除一个任务 </span><br><span class="line">     *  </span><br><span class="line">     * @param jobName </span><br><span class="line">     * @param jobGroupNamee</span><br><span class="line">     */</span><br><span class="line">    public void removeJob(String jobName, String jobGroupNamee) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line"></span><br><span class="line">            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupNamee);</span><br><span class="line"></span><br><span class="line">            sched.pauseTrigger(triggerKey);// 停止触发器  </span><br><span class="line">            sched.unscheduleJob(triggerKey);// 移除触发器  </span><br><span class="line">            sched.deleteJob(JobKey.jobKey(jobName, jobGroupNamee));// 删除任务  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * @Description:启动所有定时任务 </span><br><span class="line">     */  </span><br><span class="line">    public void startJobs() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">            sched.start();  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * @Description:关闭所有定时任务 </span><br><span class="line">     */  </span><br><span class="line">    public void shutdownJobs() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">            if (!sched.isShutdown()) &#123;  </span><br><span class="line">                sched.shutdown();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pauseTrigger(String jobName, String jobGroupName)&#123;</span><br><span class="line">        Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">        TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);</span><br><span class="line">        try &#123;</span><br><span class="line">        // 停止触发器  </span><br><span class="line">sched.pauseTrigger(triggerKey);</span><br><span class="line">&#125; catch (SchedulerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void resumeTrigger(String jobName, String jobGroupName)&#123;</span><br><span class="line">        Scheduler sched = mySchedulerFactory.getScheduler();  </span><br><span class="line">        TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);</span><br><span class="line">        try &#123;</span><br><span class="line">        // 恢复触发器  </span><br><span class="line">sched.resumeTrigger(triggerKey);</span><br><span class="line">&#125; catch (SchedulerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="taskjob">TaskJob</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.hermes.taskmanager.schedule;</span><br><span class="line"></span><br><span class="line">//import com.qunar.marmot.adhoc.enums.Unit;</span><br><span class="line">//import com.qunar.marmot.adhoc.model.task.TaskTemplate;</span><br><span class="line">//import com.qunar.marmot.adhoc.service.TaskService;</span><br><span class="line">//import com.qunar.marmot.adhoc.service.TaskTemplateService;</span><br><span class="line">import org.quartz.JobDetail;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line">import org.springframework.scheduling.quartz.QuartzJobBean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class TaskJob extends QuartzJobBean &#123;</span><br><span class="line">private static org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TaskJob.class);</span><br><span class="line">//@Resource</span><br><span class="line">//TaskService taskService;</span><br><span class="line">//@Resource</span><br><span class="line">//TaskTemplateService taskTemplateService;</span><br><span class="line"></span><br><span class="line">public void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            JobDetail jobDetail = context.getJobDetail();</span><br><span class="line">            logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;task schedule start! - executing its JOB at &quot;+ new Date() + &quot; by &quot; + context.getTrigger().getCalendarName() +&quot; , taskTemplateId: &quot;+jobDetail.getJobDataMap().get(&quot;taskTemplateId&quot;));</span><br><span class="line"></span><br><span class="line">//            TaskTemplate taskTemplate = taskTemplateService.getTaskTemplateById(Integer.parseInt(jobDetail.getJobDataMap().get(&quot;taskTemplateId&quot;).toString()));</span><br><span class="line">//            创建任务</span><br><span class="line">//            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">//            taskService.createTask(taskTemplate, Unit.DAILY.getValue(), 1,sdf.format(new Date()), sdf.format(new Date()));</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            logger.error(&quot;定时任务创建图表任务失败：&#123;&#125;&quot;,e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="添加定时任务service">添加定时任务service</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">    ScheduleManager scheduleManager;</span><br><span class="line"></span><br><span class="line">    public void add(TaskTemplate tmp)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">//            SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">//            tmp.setCreateTime(df.parse(df.format(new Date())));</span><br><span class="line">//            tmp.setUpdateTime(df.parse(df.format(new Date())));</span><br><span class="line">//</span><br><span class="line">            //默认支持二次查询</span><br><span class="line">//tmp.setResultQuery(1);</span><br><span class="line">            //创建定时任务</span><br><span class="line">            JobDataMap jobDataMap = new JobDataMap();</span><br><span class="line">            jobDataMap.put(&quot;taskTemplateId&quot;, tmp.getId()+&quot;&quot;);</span><br><span class="line">            scheduleManager.addJob(Constant.GROUP_PREFIX+tmp.getId(), Constant.TASK_GROUP, TaskJob.class,tmp.getCrontab(),jobDataMap);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;创建定时任务失败&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1><span id="controller">controller</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//设置定时任务</span><br><span class="line">    @RequestMapping(value = &quot;BatchIndexApiScheduleTask/v1&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span><br><span class="line">    public Object newTask(@RequestBody TaskTemplate taskTemplate) &#123;</span><br><span class="line">        taskTemplate.setCrontab(&quot;0 0 7 * * ?&quot;);</span><br><span class="line">        scheduleTaskService.addIngest(taskTemplate);</span><br><span class="line">        return new ResultVo(Constant.SUCCESS_CODE, taskTemplate.getId(), &quot;设置成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭定时任务</span><br><span class="line">    @RequestMapping(value = &quot;BatchIndexApiShutdownJobs/v1&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span><br><span class="line">    public Object shutdownJobs() &#123;</span><br><span class="line">        scheduleManager.shutdownJobs();</span><br><span class="line">        return new ResultVo(Constant.SUCCESS_CODE, &quot;&quot;, &quot;关闭成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //关闭定时任务</span><br><span class="line">    @RequestMapping(value = &quot;BatchIndexApiShutdownJobs/v1&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span><br><span class="line">    public Object shutdownJobs(@RequestBody ScheduleTask task) &#123;</span><br><span class="line">        if (task.getOperType().equalsIgnoreCase(&quot;removeJob&quot;))&#123;</span><br><span class="line">            scheduleManager.removeJob(task.getJobName(),task.getJobGroupName());</span><br><span class="line">        &#125; else if (task.getOperType().equalsIgnoreCase(&quot;resumeTrigger&quot;))&#123;</span><br><span class="line">            scheduleManager.resumeTrigger(task.getJobName(),task.getJobGroupName());</span><br><span class="line">        &#125; else if (task.getOperType().equalsIgnoreCase(&quot;pauseTrigger&quot;))&#123;</span><br><span class="line">            scheduleManager.pauseTrigger(task.getJobName(),task.getJobGroupName());</span><br><span class="line">        &#125;</span><br><span class="line">        return new ResultVo(Constant.SUCCESS_CODE, &quot;&quot;, &quot;关闭成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1><span id="如果有默认定时不提倡">如果有默认定时，不提倡</span></h1><p>springboot自动把Trigger注入schedulerFactoryBean中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class QuartzConfig &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 定义JobDetail 直接使用 jobDetailFactoryBean.getObject 获得的是空</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JobDetailFactoryBean printTimeJobDetail()&#123;</span><br><span class="line">        JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean();</span><br><span class="line">        // durability 表示任务完成之后是否依然保留到数据库，默认falses</span><br><span class="line">        jobDetailFactoryBean.setDurability(true);</span><br><span class="line">        //当Quartz服务被中止后，再次启动或集群中其他机器接手任务时会尝试恢复执行之前未完成的所有任务</span><br><span class="line">        jobDetailFactoryBean.setRequestsRecovery(true);</span><br><span class="line">        jobDetailFactoryBean.setJobClass(MyDetailQuartzJobBean.class);</span><br><span class="line">        jobDetailFactoryBean.setDescription(&quot;打印时间定时器2&quot;);</span><br><span class="line">        Map&lt;String,String&gt; jobDataAsMap = new HashMap&lt;&gt;();</span><br><span class="line">        jobDataAsMap.put(&quot;targetObject&quot;,&quot;printTimeQuartz&quot;); //spring 中bean的名字</span><br><span class="line">        jobDataAsMap.put(&quot;targetMethod&quot;,&quot;execute&quot;);   //执行方法名</span><br><span class="line">        jobDetailFactoryBean.setJobDataAsMap(jobDataAsMap);</span><br><span class="line">        return  jobDetailFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 定义一个Trigger</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CronTriggerFactoryBean printTimeCronTrigger(JobDetail printTimeJobDetail)&#123;</span><br><span class="line">        CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean();</span><br><span class="line">        // 设置jobDetail</span><br><span class="line">        cronTriggerFactoryBean.setJobDetail(printTimeJobDetail);</span><br><span class="line">        //秒 分 小时 日 月 星期 年  每10分钟</span><br><span class="line">        cronTriggerFactoryBean.setCronExpression(&quot;0 0/10 * * * ?&quot;);</span><br><span class="line">        //trigger超时处理策略 默认1：总是会执行头一次 2:不处理</span><br><span class="line">        cronTriggerFactoryBean.setMisfireInstruction(2);</span><br><span class="line">        return  cronTriggerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://blog.csdn.net/zl_momomo/article/details/83584315" target="_blank" rel="noopener">Spring Boot2.x 整合quartz集群</a><br><a href="https://www.liangzl.com/get-article-detail-718.html" target="_blank" rel="noopener">springboot使用quartz集群定时任务</a><br><a href="https://blog.csdn.net/zl_momomo/article/category/7780445" target="_blank" rel="noopener">分类</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之controller切面日志</title>
      <link href="/2019/05/09/springboot-controller%E5%88%87%E9%9D%A2%E6%97%A5%E5%BF%97/"/>
      <url>/2019/05/09/springboot-controller%E5%88%87%E9%9D%A2%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="controller输入输出切面日志">controller输入输出切面日志</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package com.mafengwo.hermes.taskmanager.aop;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lifei</span><br><span class="line"> * Created in 2019-05-09</span><br><span class="line"> * Description</span><br><span class="line"> */</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestAttributes;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.net.URLDecoder;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component//定义一个切面</span><br><span class="line">public class LogRecordAspect &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(LogRecordAspect.class);</span><br><span class="line">    public final String string = &quot;execution(*  *..*.*.controller..*.*(..))&quot;;</span><br><span class="line">    private static final String UTF_8 = &quot;utf-8&quot;;</span><br><span class="line"></span><br><span class="line">    // 定义切点Pointcut</span><br><span class="line">    @Pointcut(string)</span><br><span class="line">    public void excudeService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行切点 之前</span><br><span class="line">    @Before(&quot;excudeService()&quot;)</span><br><span class="line">    public void exBefore(JoinPoint pjp)&#123;</span><br><span class="line">        RequestAttributes ra = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        ServletRequestAttributes sra = (ServletRequestAttributes) ra;</span><br><span class="line">        HttpServletRequest request = sra.getRequest();</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(&quot;startTime&quot;,startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通知（环绕）</span><br><span class="line">    @Around(&quot;excudeService()&quot;)</span><br><span class="line">    public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        RequestAttributes ra = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        ServletRequestAttributes sra = (ServletRequestAttributes) ra;</span><br><span class="line">        HttpServletRequest request = sra.getRequest();</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">//        String url = request.getRequestURL().toString();</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        String queryString = request.getQueryString();</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        String params = &quot;&quot;;</span><br><span class="line">        // result的值就是被拦截方法的返回值</span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line">        try &#123;</span><br><span class="line">            long startTime = (long) request.getAttribute(&quot;startTime&quot;);</span><br><span class="line">            //获取请求参数集合并进行遍历拼接</span><br><span class="line">            if (args.length &gt; 0) &#123;</span><br><span class="line">                if (&quot;POST&quot;.equals(method)) &#123;</span><br><span class="line">                    Object object = args[0];</span><br><span class="line">                    params = JSON.toJSONString(object, SerializerFeature.WriteMapNullValue);</span><br><span class="line">                &#125; else if (&quot;GET&quot;.equals(method)) &#123;</span><br><span class="line">                    params = queryString;</span><br><span class="line">                &#125;</span><br><span class="line">                params = URLDecoder.decode(params,UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(&quot;requestMethod:&#123;&#125;#####url:&#123;&#125;#####params:&#123;&#125;#####responseBody:&#123;&#125;#####elapsed:&#123;&#125;ms.&quot;, method , uri,  params,</span><br><span class="line">                    JSON.toJSONString(result,SerializerFeature.WriteMapNullValue),(endTime - startTime));</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;log error !!&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //    执行切点之后</span><br><span class="line">    @After(&quot;excudeService()&quot;)</span><br><span class="line">    public void exAfter(JoinPoint joinPoint)  &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.mafengwo.mdps.index.search.web..*.*(..))</span><br></pre></td></tr></table></figure><p>第一个星号不能少</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot集锦</title>
      <link href="/2019/05/09/springboot%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
      <url>/2019/05/09/springboot%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#端口被占用">端口被占用</a></li></ul><!-- tocstop --><h1><span id="端口被占用">端口被占用</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name &apos;eurekaAutoServiceRegistration&apos;: Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid源码</title>
      <link href="/2019/05/05/druid%E6%BA%90%E7%A0%81/"/>
      <url>/2019/05/05/druid%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>核心项目<br>processing                内部数据结构和处理<br>server                    组合各种功能类，形成服务<br>indexing-service          索引服务,需要接收各种请求<br>services                  构建物理服务，包括命令行解析，依赖common/server/indexing-hadoop/indexing-service<br>api                       对外访问接口，解析各种访问   </p><p>Column<br>Segment<br>IndexIO<br>IndexMerger<br>IncrementalIndex<br>Main   org.apache.druid.cli.Main</p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid源码之segment</title>
      <link href="/2019/05/05/druid-segment%E6%BA%90%E7%A0%81/"/>
      <url>/2019/05/05/druid-segment%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Column在Druid中用于管理单列;Segment则用于管理一组列,这组列包括了Dimension和Metric。      </p><p><img src="/images/pasted-68.png" alt="upload successful"><br>我们首先看下Segment的定义接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.druid.segment;</span><br><span class="line"></span><br><span class="line">import org.apache.druid.guice.annotations.PublicApi;</span><br><span class="line">import org.joda.time.Interval;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Nullable;</span><br><span class="line">import java.io.Closeable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> */</span><br><span class="line">@PublicApi</span><br><span class="line">public interface Segment extends Closeable</span><br><span class="line">&#123;</span><br><span class="line">  String getIdentifier();</span><br><span class="line">  Interval getDataInterval();</span><br><span class="line">  @Nullable</span><br><span class="line">  QueryableIndex asQueryableIndex();</span><br><span class="line">  StorageAdapter asStorageAdapter();</span><br><span class="line">  </span><br><span class="line">  &lt;T&gt; T as(Class&lt;T&gt; clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>getIdentifier：返回该segment的唯一标识。其格式为：<datasource><em><start></start></em><end><em><version></version></em><partitionnum></partitionnum></end></datasource></li><li>getDataInterval：返回了一个Interval对象。表明该segment数据所在的起止时间 </li><li>as方法如上面注释所述，给自定义segment提供了一个转换用的接口。   <ol><li>asQueryableIndex：这个方法返回了一个QueryableIndex对象。QueryableIndex是面向查询的数据接口。<strong>它提供了访问每一列的能力</strong>。   </li><li>asStorageAdaptor：这个方法提供了一个StorageAdaptor对象。StorageAdaptor提供了游标（cursor）的功能，<strong>它提供了查询每行数据的能力</strong>。   </li></ol></li></ul><p>QueryableIndex在一定方式下可以转换成StorageAdaptor接口。</p><ol><li>QueryableIndex</li></ol><p>QueryableIndex提供了访问每一列的能力，支持对某些列的查询.<br>其中Metadata提供了segment的元数据，如列名等。他实现了ColumnSelector，这个接口用于选择一个列。因此，QueryableIndex可以提供精细到列的查询。  </p><ol start="2"><li><p>StorageAdaptor<br>StorageAdaptor实现了CursorFactory，可以通过游标访问每一行数据，包括对数据进行过滤等。   </p></li><li><p>IncrementalIndex</p></li></ol><p>IncrementalIndex是增量索引的核心结构，他实现了Iterable<row>接口，并且支持通过add(InputRow row)方法来插入新的数据，新数据的metric通过aggregator进行聚合。其逻辑为：如果新加入的一行在segment中已经存在了，它会增加metric的值，而不是新增一行。<br>其聚合的方法即为addToFacts方法。</row></p><p>QueryableInxexStorageAdaptor提供了从QueryableIndex适配成StorageAdaptor的实现。<br>IncrementalIndexStorageAdaptor提供了从IncrementalIndex适配成StorageAdaptor的实现，在转化过程中，构建一个游标，并将列中的每一个值都加入到row中。    </p><p><img src="/images/pasted-69.png" alt="upload successful"></p><ol start="4"><li>装载索引文件：IndexIO</li></ol><p>IndexIO提供了装载文件的功能：使用loadIndex(File inDir)方法将segment从文件中load起来。它返回一个QueryableIndex对象。   </p><p>IndexLoader是真正的干活的对象。这个类会将存储segment的index.zip文件中的所有的drd文件加载到内存中，生成一个QueryableIndex对象返回。      </p><p><img src="/images/pasted-71.png" alt="upload successful"><br><img src="/images/pasted-70.png" alt="upload successful"></p><ol start="5"><li>索引持久化</li></ol><p>在segment的生成过程中，需要将segment进行持久化，保存到deep storage中。IndexMerger负责索引的持久化</p><p><img src="/images/pasted-67.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2019/05/05/redis/"/>
      <url>/2019/05/05/redis/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redis-数据类型">Redis 数据类型</a></li><li><a href="#事务">事务</a></li></ul><!-- tocstop --><h1><span id="redis-数据类型">Redis 数据类型</span></h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><blockquote><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</p></blockquote><p>基数估算,发布订阅   </p><h1><span id="事务">事务</span></h1><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p><strong>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql回滚</title>
      <link href="/2019/05/05/mysql%E5%9B%9E%E6%BB%9A/"/>
      <url>/2019/05/05/mysql%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。   </p><p>事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 insert,update,delete 语句</li></ul><p>参考：<br><a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">MySQL 事务</a>   </p><p><a href="https://cloud.tencent.com/developer/article/1067441" target="_blank" rel="noopener">MySQL 中的重做日志，回滚日志以及二进制日志的简单总结</a></p><p><a href="https://www.cnblogs.com/ld-swust/p/5607983.html" target="_blank" rel="noopener">关于MySQL回滚机制</a></p><p><a href="https://www.cnblogs.com/takumicx/p/9998844.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">数据库事务的概念及其实现原理</a></p><p><a href="https://blog.csdn.net/baidu_24545901/article/details/81478342" target="_blank" rel="noopener">数据库底层分析事务的提交和回滚的全过程</a></p><p><a href="https://blog.csdn.net/ssmdz/article/details/75385790" target="_blank" rel="noopener">如何在mysql下实现事务的提交与回滚</a></p><p><a href="https://www.cnblogs.com/davygeek/p/7995072.html" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计思想</title>
      <link href="/2019/05/05/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2019/05/05/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#设计思想-开发模式">设计思想 &amp; 开发模式</a><ul><li><a href="#ddddomain-driven-design-领域驱动设计">DDD(Domain-driven Design - 领域驱动设计)</a><ul><li><a href="#命令查询职责分离cqrs">命令查询职责分离(CQRS)</a></li><li><a href="#贫血充血模型">贫血，充血模型</a></li></ul></li><li><a href="#actor-模式">Actor 模式</a></li><li><a href="#响应式编程">响应式编程</a><ul><li><a href="#reactor">Reactor</a></li><li><a href="#rxjava">RxJava</a></li><li><a href="#vertx">Vert.x</a></li></ul></li><li><a href="#dodaf20">DODAF2.0</a></li><li><a href="#serverless">Serverless</a></li><li><a href="#service-mesh">Service Mesh</a></li></ul></li></ul><!-- tocstop --><h1><span id="设计思想-amp-开发模式">设计思想 &amp; 开发模式</span></h1><h2><span id="ddddomain-driven-design-领域驱动设计">DDD(Domain-driven Design - 领域驱动设计)</span></h2><ul><li><p><a href="https://www.cnblogs.com/netfocus/p/5548025.html" target="_blank" rel="noopener">《浅谈我对DDD领域驱动设计的理解》</a></p><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。<strong>DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）</strong>。</li><li>过程：<strong>理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度</strong>。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul></li><li><p><a href="https://www.cnblogs.com/butterfly100/p/7827870.html" target="_blank" rel="noopener">《领域驱动设计的基础知识总结》</a></p><ul><li><strong>领域（Doamin）本质上就是问题域</strong>，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li></ul></li><li><p><a href="http://www.cnblogs.com/Leo_wl/p/3866629.html" target="_blank" rel="noopener">《领域驱动设计(DDD)实现之路》</a></p><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><p><a href="http://www.hollischuang.com/archives/553" target="_blank" rel="noopener">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p></li></ul><h3><span id="命令查询职责分离cqrs">命令查询职责分离(CQRS)</span></h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><p><a href="https://www.cnblogs.com/cnblogsfans/p/4551990.html" target="_blank" rel="noopener">《领域驱动设计系列 (六)：CQRS》</a></p><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><p><a href="http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml" target="_blank" rel="noopener">《DDD CQRS架构和传统架构的优缺点比较》</a></p><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><p><a href="http://www.cnblogs.com/netfocus/p/4055346.html" target="_blank" rel="noopener">《CQRS架构简介》</a></p><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><p><a href="http://www.uml.org.cn/zjjs/201609221.asp" target="_blank" rel="noopener">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3><span id="贫血充血模型">贫血，充血模型</span></h3><ul><li><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">《贫血，充血模型的解释以及一些经验》</a><ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2><span id="actor-模式">Actor 模式</span></h2><p>TODO</p><h2><span id="响应式编程">响应式编程</span></h2><h3><span id="reactor">Reactor</span></h3><p>TODO</p><h3><span id="rxjava">RxJava</span></h3><p>TODO</p><h3><span id="vertx">Vert.x</span></h3><p>TODO</p><h2><span id="dodaf20">DODAF2.0</span></h2><ul><li><a href="http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml" target="_blank" rel="noopener">《DODAF2.0方法论》</a></li><li><a href="http://blog.51cto.com/xiaoyong/1553164" target="_blank" rel="noopener">《DODAF2.0之能力视角如何落地》</a></li></ul><h2><span id="serverless">Serverless</span></h2><p>无需过多关系服务器的服务架构理念。</p><ul><li><p><a href="http://www.jdon.com/soa/serverless.html" target="_blank" rel="noopener">《什么是Serverless无服务器架构？》</a></p><ul><li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li><li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li><li>Serverless 不代表某个具体的框架。</li></ul></li><li><p><a href="http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless" target="_blank" rel="noopener">《如何理解Serverless？》</a></p><ul><li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li></ul></li></ul><h2><span id="service-mesh">Service Mesh</span></h2><ul><li><a href="https://time.geekbang.org/article/2355" target="_blank" rel="noopener">《什么是Service Mesh？》</a></li><li><a href="https://www.jianshu.com/p/e23e3e74538e" target="_blank" rel="noopener">《初识 Service Mesh》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构六之java排序工具</title>
      <link href="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E4%B9%8Bjava%E6%8E%92%E5%BA%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E4%B9%8Bjava%E6%8E%92%E5%BA%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>Collections.sort底层调用的是Arrays.sort()，再底层是TimSort.sort。     </p><p><code>Arrays.sort(T[], Comparator &lt; ? super T &gt; c)</code>方法用于对象数组按用户自定义规则排序.<strong>策略模式</strong>。<br>binarySort源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start,</span><br><span class="line">                                       Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        assert lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">        if (start == lo)</span><br><span class="line">            start++;</span><br><span class="line">        for ( ; start &lt; hi; start++) &#123;</span><br><span class="line">            T pivot = a[start];</span><br><span class="line"></span><br><span class="line">            // Set left (and right) to the index where a[start] (pivot) belongs</span><br><span class="line">            int left = lo;</span><br><span class="line">            int right = start;</span><br><span class="line">            assert left &lt;= right;</span><br><span class="line">            /*</span><br><span class="line">             * Invariants:</span><br><span class="line">             *   pivot &gt;= all in [lo, left).</span><br><span class="line">             *   pivot &lt;  all in [right, start).</span><br><span class="line">             */</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int mid = (left + right) &gt;&gt;&gt; 1;</span><br><span class="line">                if (c.compare(pivot, a[mid]) &lt; 0)</span><br><span class="line">                    right = mid;</span><br><span class="line">                else</span><br><span class="line">                    left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            assert left == right;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * The invariants still hold: pivot &gt;= all in [lo, left) and</span><br><span class="line">             * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span><br><span class="line">             * that if there are elements equal to pivot, left points to the</span><br><span class="line">             * first slot after them -- that&apos;s why this sort is stable.</span><br><span class="line">             * Slide elements over to make room for pivot.</span><br><span class="line">             */</span><br><span class="line">            int n = start - left;  // The number of elements to move</span><br><span class="line">            // Switch is just an optimization for arraycopy in default case</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case 2:  a[left + 2] = a[left + 1];</span><br><span class="line">                case 1:  a[left + 1] = a[left];</span><br><span class="line">                         break;</span><br><span class="line">                default: System.arraycopy(a, left, a, left + 1, n);</span><br><span class="line">            &#125;</span><br><span class="line">            a[left] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>总结：<br>不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来</p><p>参考：<br><a href="https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1" target="_blank" rel="noopener">Arrays.sort和Collections.sort实现原理解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四之二分查找</title>
      <link href="/2019/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E4%B9%8B%E6%A0%91/"/>
      <url>/2019/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E4%B9%8B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二分查找法的使用重点不在于查找和目标值相等的值，重点在于查找大于等于x的最小值、小于等于x的最大值。   </p><p><img src="/images/pasted-66.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.search;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">    static int[] arr = &#123;2,4,6,8,10,12,14&#125;;</span><br><span class="line">    int target = 11;</span><br><span class="line"></span><br><span class="line">//    版本1</span><br><span class="line">//    当区间[l, r]的更新操作是r = mid; l = mid + 1;时，计算mid时不需要加1。</span><br><span class="line">//    大于等于11(查找数)中最小值</span><br><span class="line">    int bs_1(int left,int right)&#123;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (arr[mid] &gt;= target) right = mid;</span><br><span class="line">            else left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[left];//12</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    版本2</span><br><span class="line">//    当区间[l, r]的更新操作是r = mid - 1; l = mid;时，计算mid时需要加1。</span><br><span class="line">//    小于等于11(查找数)中最大值。  10</span><br><span class="line">    int bs_2(int left,int right)&#123;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int mid = (left + right + 1) / 2;</span><br><span class="line">            if (arr[mid] &gt;= target) right = mid - 1;</span><br><span class="line">            else left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[left];//10</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinarySearch bs = new BinarySearch();</span><br><span class="line">        System.out.println(bs.bs_1(0,arr.length - 1));//12</span><br><span class="line">        System.out.println(bs.bs_2(0,arr.length - 1));//10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://www.cnblogs.com/coderising/p/5708632.html" target="_blank" rel="noopener">二分查找</a><br><a href="https://www.acwing.com/blog/content/91/" target="_blank" rel="noopener">acwing</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五之常用排序</title>
      <link href="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#插入排序">插入排序</a><ul><li><a href="#直接插入排序">直接插入排序</a></li><li><a href="#二分插入排序">二分插入排序</a></li><li><a href="#希尔排序">希尔排序</a></li></ul></li><li><a href="#选择排序">选择排序</a><ul><li><a href="#直接选择排序">直接选择排序</a></li><li><a href="#堆排序">堆排序</a></li></ul></li><li><a href="#交换排序">交换排序</a><ul><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#快速排序">快速排序</a></li></ul></li><li><a href="#归并排序">归并排序</a></li><li><a href="#基数排序">基数排序</a></li></ul><!-- tocstop --><p>每种算法都有它特定的使用场合，很难通用。因此，我们很有必要对所有常见的排序算法进行归纳。</p><p>内排序有可以分为以下几类：<br>　　(1)、插入排序：<strong>直接插入排序</strong>、二分法插入排序、希尔排序。<br>　　(2)、选择排序：直接选择排序、堆排序。<br>　　(3)、交换排序：<strong>冒泡排序</strong>、快速排序。<br>　　(4)、<strong>归并排序</strong><br>　　(5)、<strong>基数排序</strong>   </p><p>加粗标识稳定排序    </p><ol><li>是否稳定   </li><li>空间要求   </li><li>时间要求   </li></ol><p><img src="/images/pasted-56.png" alt="upload successful"></p><h1><span id="插入排序">插入排序</span></h1><ul><li>思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。 </li><li>关键问题：在前面已经排好序的序列中找到合适的插入位置。 </li></ul><h2><span id="直接插入排序">直接插入排序</span></h2><p><strong>从后向前找到合适位置后插入</strong><br>1、基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。</p><p>2、实例<br><img src="/images/pasted-57.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.insert;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">public class DirectInsertSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        int[] a = &#123; 57,68,59,52 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;//外层循环</span><br><span class="line">            int temp = a[i];// 待插入元素第i个元素</span><br><span class="line">            int j;</span><br><span class="line">            for(j = i - 1; j &gt;= 0; j--)&#123;//内层循环 将大于temp的往后移动一位; todo 从后向前找到合适位置后插入</span><br><span class="line">                if (a[j] &gt; temp)//前一项值大于待插入值</span><br><span class="line">                    //将a[j] 赋值给 a[j + 1]</span><br><span class="line">                    a[j + 1] = a[j];//todo 所以前一项往后移;直到不能移动,j+1就是正确位置；</span><br><span class="line">                else</span><br><span class="line">                    break;//找到合适位置</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="二分插入排序">二分插入排序</span></h2><p>按二分法找到合适位置插入<br>1、基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里是按二分法找到合适的位置，可以减少比较的次数。</p><p>2、实例</p><p><img src="/images/pasted-58.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.insert;</span><br><span class="line"></span><br><span class="line">public class BinaryInsertSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length;i++)&#123;//外层循环</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            int low = 0;</span><br><span class="line">            int high = i - 1;</span><br><span class="line">            int mid = 0;</span><br><span class="line">            while (low &lt;= high)&#123;</span><br><span class="line">                mid = (low + high) / 2;</span><br><span class="line">                if (temp &lt; a[mid])</span><br><span class="line">                    high = mid - 1;</span><br><span class="line">                else</span><br><span class="line">                    low = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            //此时left就是合适的位置</span><br><span class="line">            for (int j = i - 1; j &gt;= low;j--)&#123;//内层循环</span><br><span class="line">                a[j+1] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (low != i)</span><br><span class="line">                a[low] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="希尔排序">希尔排序</span></h2><p>1、基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。<strong>所有距离为d1的倍数的记录放在同一个组中</strong>。先在各组内进行直接插入排序；然后，取第二个增量d2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.insert;</span><br><span class="line"></span><br><span class="line">public class ShellInsertSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        int d = a.length;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            d = d / 2;</span><br><span class="line">            for (int x = 0;x &lt; d;x++)&#123;</span><br><span class="line">                for (int i = x + d; i &lt; a.length; i = i + d) &#123;//跨度是d</span><br><span class="line">                    int temp = a[i];</span><br><span class="line">                    int j = 0;</span><br><span class="line">                    for (j = i - d; j &gt;= 0 &amp;&amp; a[j] &gt; temp ; j = j - d) &#123;//跨度是d</span><br><span class="line">                        a[j + d] = a[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[j + d] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (d == 1) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="选择排序">选择排序</span></h1><p>每次选择最小的记录    </p><ul><li>思想：每趟从待排序的记录序列中选择关键字<strong>最小的记录</strong>放置到已排序表的最前位置，直到全部排完。 </li><li>关键问题：在剩余的待排序记录序列中找到最小关键码记录。 </li></ul><h2><span id="直接选择排序">直接选择排序</span></h2><p>1、基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p><p>2、实例</p><p><img src="/images/pasted-59.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.select;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">public class DirectSelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            int min = a[i];//i标识当前值索引</span><br><span class="line">            int n = i;// 最小值的索引</span><br><span class="line">            for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (a[j] &lt; min)&#123;// 找出最小的数</span><br><span class="line">                    min = a[j];</span><br><span class="line">                    n = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //交换当前值和最小值</span><br><span class="line">            a[n] = a[i];</span><br><span class="line">            a[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="堆排序">堆排序</span></h2><p>1、基本思想：<br>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p><p>堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。</p><p>　　思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。<br>2、实例</p><p>初始序列：46,79,56,38,40,84<br>建堆：<br><img src="/images/pasted-60.png" alt="upload successful"><br>交换，从堆中踢出最大数<br><img src="/images/pasted-61.png" alt="upload successful"><br>依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.select;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class HeapSelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            // 建大顶堆，即根元素最大</span><br><span class="line">            buildMaxHeap(a,a.length - 1 - i);</span><br><span class="line">            Util.swap(a,0,a.length - 1 - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组长度6，最大索引5，i = (5 - 1)/2=2;</span><br><span class="line">    //数组长度7，最大索引6，i = (6 - 1)/2=2.5=2;</span><br><span class="line">    //根据索引判断时，2k+1时左节点，2k+2是右节点</span><br><span class="line">//              0</span><br><span class="line">//           1      2</span><br><span class="line">//         3   4  5   6</span><br><span class="line"></span><br><span class="line">    //todo 如果堆得序号从1开始，则左右节点为2*k,2*k + 1</span><br><span class="line">    // 对data数组从0到lastIndex建大顶堆</span><br><span class="line">//              1</span><br><span class="line">//           2      3</span><br><span class="line">//         4   5  6   7</span><br><span class="line">    private static void buildMaxHeap(int[] data, int lastIndex) &#123;</span><br><span class="line">        // 从lastIndex处节点（最后一个节点）的父节点开始</span><br><span class="line">        for (int i = (lastIndex - 1)/ 2; i &gt;= 0; i--)&#123;</span><br><span class="line">            //todo k保存正在判断的节点</span><br><span class="line">            int k = i;</span><br><span class="line">            // 如果当前k节点的子节点存在</span><br><span class="line">            while (k * 2 + 1 &lt;= lastIndex)&#123;</span><br><span class="line">                //k节点的左子节点的索引</span><br><span class="line">                int biggerIndex = 2 * k + 1;</span><br><span class="line">                // 如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span><br><span class="line">                if (biggerIndex &lt; lastIndex)&#123;</span><br><span class="line">                    // 若果右子节点的值较大</span><br><span class="line">                    if (data[biggerIndex] &lt; data[biggerIndex + 1])&#123;//比较左节点和右节点</span><br><span class="line">                        // biggerIndex总是记录较大子节点的索引</span><br><span class="line">                        biggerIndex++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //todo 如果k节点的值小于其较大的子节点的值</span><br><span class="line">                if (data[k] &lt; data[biggerIndex])&#123;</span><br><span class="line">                    // 交换他们</span><br><span class="line">                    Util.swap(data, k, biggerIndex);</span><br><span class="line">                    //todo 将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span><br><span class="line">                    k = biggerIndex;</span><br><span class="line">                &#125; else break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="交换排序">交换排序</span></h1><h2><span id="冒泡排序">冒泡排序</span></h2><p>1、基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下<strong>对相邻的两个数依次进行比较和调整</strong>，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><p>2、实例</p><p><img src="/images/pasted-62.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.swap;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将最大值冒泡上去，小指自然下沉</span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; a.length - i - 1; j++) &#123;//a.length - i - 1</span><br><span class="line">                if (a[j] &gt; a[j + 1])//j , j + 1</span><br><span class="line">                    Util.swap(a,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="快速排序">快速排序</span></h2><p>1、基本思想：<strong>选择一个基准元素</strong>,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</p><p>2、实例</p><p><img src="/images/pasted-63.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.swap;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        if (a.length &gt; 0)</span><br><span class="line">            quickSort(a,0,a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void quickSort(int[] a, int low, int high) &#123;</span><br><span class="line">        if (low &lt; high)&#123;</span><br><span class="line">            int mid = getMiddle(a,low,high);</span><br><span class="line">            quickSort(a,low,mid - 1);//todo mid - 1</span><br><span class="line">            quickSort(a,mid + 1,high);//todo mid + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getMiddle(int[] a, int low, int high) &#123;</span><br><span class="line">        int temp = a[low];</span><br><span class="line">        while (low &lt; high)&#123;</span><br><span class="line">            while (low &lt; high &amp;&amp; a[high] &gt;= temp)&#123;//temp , &gt;=</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[low] = a[high];//将最大值赋给最小值</span><br><span class="line">            while (low &lt; high &amp;&amp; a[low] &lt;= temp)&#123;//temp , &lt;=</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[high] = a[low];//将最小值赋给最大值</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = temp;//low = high即middle</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="归并排序">归并排序</span></h1><p>1、基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p>2、实例</p><p><img src="/images/pasted-64.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.merge;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a,0,a.length - 1);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a, int low, int high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low &lt; high)&#123;</span><br><span class="line">            sortArray(a,low,mid);</span><br><span class="line">            sortArray(a,mid + 1,high);</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp = new int[high - low + 1];</span><br><span class="line">        int i = low;// 左指针</span><br><span class="line">        int j = mid + 1;// 右指针</span><br><span class="line">        int k = 0;</span><br><span class="line"></span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">            if (a[i] &lt; a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把左边剩余的数移入数组</span><br><span class="line">        while (i &lt;= mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 把右边边剩余的数移入数组</span><br><span class="line">        while (j &lt;= high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把新数组中的数覆盖nums数组</span><br><span class="line">        for (int l = 0; l &lt; temp.length; l++) &#123;</span><br><span class="line">            a[l + low] = temp[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="基数排序">基数排序</span></h1><p>1、基本思想：将所有待比较数值（正整数）统一为同样的数位长度，<strong>数位较短的数前面补零</strong>。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><p>2、实例</p><p><img src="/images/pasted-65.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.sort.base;</span><br><span class="line"></span><br><span class="line">import com.example.demo.sort.Util;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class BaseSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1 &#125;;</span><br><span class="line">        Util.printArr(a,&quot;排序前:&quot;);</span><br><span class="line">        sortArray(a);</span><br><span class="line">        Util.printArr(a,&quot;排序后:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sortArray(int[] a) &#123;</span><br><span class="line">        // 找到最大数，确定要排序几趟</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (max &lt; a[i])</span><br><span class="line">                max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断位数</span><br><span class="line">        int times = 0;</span><br><span class="line">        while (max &gt; 0)&#123;</span><br><span class="line">            max = max / 10;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //建立十个队列</span><br><span class="line">        List&lt;ArrayList&gt; queue = new ArrayList&lt;ArrayList&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            ArrayList q = new ArrayList();</span><br><span class="line">            queue.add(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //进行times次分配和收集</span><br><span class="line">        for (int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">            //分配</span><br><span class="line">            for (int j = 0; j &lt; a.length; j++) &#123;</span><br><span class="line">                int x = a[j] % (int)Math.pow(10,i + 1)/(int)Math.pow(10,i);</span><br><span class="line">                ArrayList q = queue.get(x);</span><br><span class="line">                q.add(a[j]);</span><br><span class="line">                queue.set(x,q);</span><br><span class="line">            &#125;</span><br><span class="line">            //收集</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">                while (queue.get(j).size() &gt; 0) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; q = queue.get(j);</span><br><span class="line">                    a[count] = q.get(0);</span><br><span class="line">                    q.remove(0);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">常见排序算法及对应的时间复杂度和空间复杂度</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maxwell</title>
      <link href="/2019/04/29/Canal-Maxwell/"/>
      <url>/2019/04/29/Canal-Maxwell/</url>
      
        <content type="html"><![CDATA[<h1><span id="github">github</span></h1><p><img src="/images/pasted-49.png" alt="upload successful"></p><h1><span id="对比">对比</span></h1><p><img src="/images/pasted-50.png" alt="upload successful"></p><h1><span id="选择">选择</span></h1><p><img src="/images/pasted-51.png" alt="upload successful"></p><h1><span id="安装">安装</span></h1><p><img src="/images/pasted-52.png" alt="upload successful"></p><p><img src="/images/pasted-53.png" alt="upload successful"></p><p><img src="/images/pasted-54.png" alt="upload successful"></p><p><img src="/images/pasted-55.png" alt="upload successful"></p><p>参考：<br><a href="http://maxwells-daemon.io/" target="_blank" rel="noopener">maxwell官网</a></p>]]></content>
      
      
      <categories>
          
          <category> canal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之脚本</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start_allsh">start_all.sh</a></li><li><a href="#stop_allsh">stop_all.sh</a></li><li><a href="#common-path">Common Path</a></li><li><a href="#overload">overload</a></li><li><a href="#middlemanager">middleManager</a></li><li><a href="#coordinator">Coordinator</a></li><li><a href="#historical">historical</a></li><li><a href="#broker">broker</a></li><li><a href="#router">router</a></li><li><a href="#confdruid_common">conf/druid/_common</a></li><li><a href="#各个节点配置">各个节点配置</a><ul><li><a href="#jvm">jvm</a></li><li><a href="#runtime">runtime</a></li></ul></li><li><a href="#star_tasksh">star_task.sh</a><ul><li><a href="#web_proxy_templete">web_proxy_templete</a></li></ul></li></ul><!-- tocstop --><h1><span id="start_allsh">start_all.sh</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#start druid</span><br><span class="line">function start_druid()&#123;</span><br><span class="line">    host=$1</span><br><span class="line">    #host=$&#123;host// / &#125;</span><br><span class="line">    shift</span><br><span class="line">    type=$1</span><br><span class="line">    for hn in $host</span><br><span class="line">    do</span><br><span class="line">      echo &quot;start $type node($hn)....&quot;</span><br><span class="line">      ssh -p 333 $hn &quot;/bin/sh /usr/local/datacenter/druid/run/start_$&#123;type&#125;.sh&quot;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">for command  in overlord  middleManager coordinator historical broker</span><br><span class="line">do</span><br><span class="line">  case $command in</span><br><span class="line">     (overlord)</span><br><span class="line">         start_druid &quot;node007008 node007009 node007010&quot; &quot;overlord&quot;</span><br><span class="line">     ;;</span><br><span class="line">     (middleManager)</span><br><span class="line">         start_druid &quot;node007008 node007009 node007010&quot; &quot;middleManager&quot;</span><br><span class="line">     ;;</span><br><span class="line">     (historical)</span><br><span class="line">         start_druid &quot;node007002 node007003 node007004&quot; &quot;historical&quot;</span><br><span class="line">     ;;</span><br><span class="line">     (coordinator)</span><br><span class="line">         start_druid &quot;node007008 node007009 node007010&quot; &quot;coordinator&quot;</span><br><span class="line">     ;;</span><br><span class="line">     (broker)</span><br><span class="line">         start_druid &quot;node007005 node007006 node007007&quot; &quot;broker&quot;</span><br><span class="line">     ;;</span><br><span class="line">     (*)</span><br><span class="line">         echo $usage</span><br><span class="line">         exit 1</span><br><span class="line">     ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol><li>overload</li><li>middleManager</li><li>coordinator</li><li>historical</li><li>broker<h1><span id="stop_allsh">stop_all.sh</span></h1></li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#kill druid force</span><br><span class="line">function stop_druid()&#123;</span><br><span class="line">    host=$1</span><br><span class="line">    shift</span><br><span class="line">    type=$1</span><br><span class="line">    for hn in $host</span><br><span class="line">    do</span><br><span class="line">        echo &quot;stop $type node($hn)&quot;</span><br><span class="line">        ssh -p 333 $hn &quot;/bin/ps aux|grep $type|grep -v &apos;grep&apos;|awk -F &apos; &apos; &apos;&#123;print \$2&#125;&apos;|xargs kill -9&quot;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="common-path">Common Path</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DRUID_HOME=/usr/local/datacenter/druid</span><br><span class="line">LORD_CONF=$DRUID_HOME/conf/druid/overlord</span><br><span class="line"></span><br><span class="line">HADOOP_HOME=/usr/local/datacenter/hadoop</span><br><span class="line">hadoop_classpath=$HADOOP_HOME/etc/hadoop:$HADOOP_HOME/share/hadoop/common/lib/*:$HADOOP_HOME/share/hadoop/common/*:$HADOOP_HOME/share/hadoop/hdfs:$HADOOP_HOME/share/hadoop/hdfs/lib/*:$HADOOP_HOME/share/hadoop/hdfs/*:$HADOOP_HOME/share/hadoop/yarn/lib/*:$HADOOP_HOME/share/hadoop/yarn/*:$HADOOP_HOME/share/hadoop/mapreduce/lib/*:$HADOOP_HOME/share/hadoop/mapreduce/*:$HADOOP_HOME/lib/native/Linux-amd64-64/*</span><br></pre></td></tr></table></figure><h1><span id="overload">overload</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup java \</span><br><span class="line"> -server -Xmx12g -Xms12g -XX:NewSize=6g -XX:MaxNewSize=6g -XX:MaxDirectMemorySize=32g  -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps\</span><br><span class="line"> -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager  -Duser.timezone=Asia/Shanghai -Djava.io.tmpdir=/tmp \</span><br><span class="line"> -classpath $DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/overlord:$DRUID_HOME/lib/*:$&#123;hadoop_classpath&#125; io.druid.cli.Main server overlord\</span><br><span class="line"> 2&gt;&amp;1 &gt; /tmp/druid_log/overlord.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="middlemanager">middleManager</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup java \</span><br><span class="line"> -server -Xmx64m -Xms64m -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps\</span><br><span class="line"> -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager  -Duser.timezone=Asia/Shanghai  -Djava.io.tmpdir=/tmp \</span><br><span class="line"> -classpath $DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/middleManager:$DRUID_HOME/lib/*:$&#123;hadoop_classpath&#125; io.druid.cli.Main server middleManager \</span><br><span class="line"> 2&gt;&amp;1 &gt; /tmp/druid_log/middleManager.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="coordinator">Coordinator</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DRUID_HOME=/usr/local/datacenter/druid</span><br><span class="line">nohup java -server -Xmx10g -Xms10g -XX:NewSize=512m -XX:MaxNewSize=512m -XX:+UseG1GC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Duser.timezone=Asia/Shanghai -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -classpath &quot;$DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/coordinator:$DRUID_HOME/lib/*&quot; io.druid.cli.Main server coordinator 2&gt;&amp;1 &gt; /tmp/druid_log/coodinator.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="historical">historical</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup java \</span><br><span class="line"> -server -Xmx12g -Xms12g -XX:NewSize=6g -XX:MaxNewSize=6g -XX:MaxDirectMemorySize=32g -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps\</span><br><span class="line"> -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -Duser.timezone=Asia/Shanghai  -Djava.io.tmpdir=/tmp \</span><br><span class="line"> -classpath $DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/historical:$DRUID_HOME/lib/*:$&#123;hadoop_classpath&#125; io.druid.cli.Main server historical \</span><br><span class="line"> 2&gt;&amp;1  &gt;/tmp/druid_log/historical.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="broker">broker</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DRUID_HOME=/usr/local/datacenter/druid</span><br><span class="line">BROKER_CONF=$DRUID_HOME/conf/druid/broker</span><br><span class="line"></span><br><span class="line"># start druid broker</span><br><span class="line">nohup java -server -Xmx25g -Xms25g -XX:NewSize=6g -XX:MaxNewSize=6g -XX:MaxDirectMemorySize=64g -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Duser.timezone=Asia/Shanghai -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -Dcom.sun.management.jmxremote.port=17071 -Djava.io.tmpdir=/tmp -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -classpath $DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/broker:$DRUID_HOME/lib/* io.druid.cli.Main server broker 2&gt;&amp;1 &gt; /tmp/druid_log/broker.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="router">router</span></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DRUID_HOME=/usr/local/datacenter/druid</span><br><span class="line">BROKER_CONF=$DRUID_HOME/conf/druid/router</span><br><span class="line"></span><br><span class="line"># start druid broker</span><br><span class="line">nohup /usr/bin/java -server -Xmx25g -Xms25g -XX:NewSize=6g -XX:MaxNewSize=6g -XX:MaxDirectMemorySize=64g -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Duser.timezone=Asia/Shanghai -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -Dcom.sun.management.jmxremote.port=17071 -Djava.io.tmpdir=/tmp -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -classpath $DRUID_HOME/conf/druid/_common:$DRUID_HOME/conf/druid/router:$DRUID_HOME/lib/* io.druid.cli.Main server router 2&gt;&amp;1 &gt; /tmp/druid_log/router.log &amp;</span><br></pre></td></tr></table></figure><h1><span id="confdruid_common">conf/druid/_common</span></h1><hr><p><img src="/images/pasted-47.png" alt="upload successful"><br>common.runtime.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">druid.extensions.loadList=[&quot;druid-examples&quot;,&quot;faicon-emitter&quot;, &quot;druid-kafka-eight&quot;, &quot;druid-histogram&quot;, &quot;druid-datasketches&quot;, &quot;druid-lookups-cached-global&quot;, &quot;mysql-metadata-storage&quot;,&quot;druid-hdfs-storage&quot;]</span><br><span class="line"></span><br><span class="line">druid.extensions.hadoopDependenciesDir=/usr/local/datacenter/druid/hadoop-dependencies</span><br><span class="line"></span><br><span class="line">druid.startup.logging.logProperties=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.zk.service.host=192.168.7.230:2181,192.168.7.231:2181,192.168.7.232:2181</span><br><span class="line">druid.zk.service.sessionTimeoutMs=1800000</span><br><span class="line">druid.zk.paths.base=/druid/tranquility</span><br><span class="line">druid.discovery.curator.path=/druid/tranquility/discovery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.metadata.storage.type=mysql</span><br><span class="line">druid.metadata.storage.connector.connectURI=jdbc\:mysql\://192.168.7.221\:3306/druid</span><br><span class="line">druid.metadata.storage.connector.user=druid</span><br><span class="line">druid.metadata.storage.connector.password=druid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.storage.type=hdfs</span><br><span class="line">druid.storage.storageDirectory=hdfs://192.168.7.233:9000/druid/segments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.indexer.logs.type=hdfs</span><br><span class="line">druid.indexer.logs.directory=hdfs://192.168.7.233:9000/druid/indexing-logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.selectors.indexing.serviceName=druid:tranquility:indexer</span><br><span class="line">druid.selectors.coordinator.serviceName=druid:tranquility:coordinator</span><br><span class="line"></span><br><span class="line">druid.cache.type=local</span><br><span class="line">druid.cache.sizeInBytes=128849018880</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.javascript.enabled=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">druid.monitoring.monitors=[&quot;com.metamx.metrics.SysMonitor&quot;,&quot;com.metamx.metrics.JvmMonitor&quot;]</span><br><span class="line">druid.emitter=faicon</span><br><span class="line">druid.emitter.faicon.host=192.168.9.110</span><br><span class="line">druid.emitter.faicon.port=8080</span><br></pre></td></tr></table></figure></p><h1><span id="各个节点配置">各个节点配置</span></h1><hr><p><img src="/images/pasted-48.png" alt="upload successful"></p><h2><span id="jvm">jvm</span></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[dongliang@node007225 druid]$ cat conf/druid/overlord/jvm.config</span><br><span class="line">-server</span><br><span class="line">-Xms3g</span><br><span class="line">-Xmx3g</span><br><span class="line">-Duser.timezone=UTC</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Djava.io.tmpdir=var/tmp</span><br><span class="line">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br><span class="line">[dongliang@node007225 druid]$ cat conf/druid/coordinator/jvm.config</span><br><span class="line">-server</span><br><span class="line">-Xms3g</span><br><span class="line">-Xmx3g</span><br><span class="line">-Duser.timezone=UTC</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Djava.io.tmpdir=var/tmp</span><br><span class="line">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br><span class="line">-Dderby.stream.error.file=var/druid/derby.log</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/middleManager/jvm.config</span><br><span class="line">-server</span><br><span class="line">-Xms64m</span><br><span class="line">-Xmx64m</span><br><span class="line">-Duser.timezone=UTC</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Djava.io.tmpdir=var/tmp</span><br><span class="line">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/historical/jvm.config</span><br><span class="line">-server</span><br><span class="line">-Xms8g</span><br><span class="line">-Xmx8g</span><br><span class="line">-XX:MaxDirectMemorySize=4096m</span><br><span class="line">-Duser.timezone=UTC</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Djava.io.tmpdir=var/tmp</span><br><span class="line">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/broker/jvm.config</span><br><span class="line">-server</span><br><span class="line">-Xms24g</span><br><span class="line">-Xmx24g</span><br><span class="line">-XX:MaxDirectMemorySize=4096m</span><br><span class="line">-Duser.timezone=UTC</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-Djava.io.tmpdir=var/tmp</span><br><span class="line">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br></pre></td></tr></table></figure><h2><span id="runtime">runtime</span></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">[xxxx@xxxx druid]$ cat conf/druid/router/runtime.properties</span><br><span class="line">druid.host=node007224</span><br><span class="line">druid.port=8085</span><br><span class="line">druid.service=druid:tranquility:router</span><br><span class="line"></span><br><span class="line">druid.processing.numThreads=1</span><br><span class="line">druid.router.defaultBrokerServiceName=druid:tranquility:broker</span><br><span class="line">druid.router.coordinatorServiceName=druid:tranquility:coordinator</span><br><span class="line">druid.router.tierToBrokerMap=&#123;&quot;hot&quot;:&quot;druid:tranquility:broker-hot&quot;,&quot;_default_tier&quot;:&quot;druid:tranquility:broker&quot;&#125;</span><br><span class="line">druid.router.http.numConnections=50</span><br><span class="line">druid.router.http.readTimeout=PT5M</span><br><span class="line"></span><br><span class="line"># Number of threads used by the router proxy http client</span><br><span class="line">druid.router.http.numMaxThreads=100</span><br><span class="line"></span><br><span class="line">druid.server.http.numThreads=100</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/overlord/runtime.properties</span><br><span class="line">druid.host=node007225</span><br><span class="line">druid.port=8080</span><br><span class="line">druid.service=druid:tranquility:indexer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run in remote mode</span><br><span class="line">druid.indexer.runner.type=remote</span><br><span class="line"># Store all task state in the metadata storage</span><br><span class="line">druid.indexer.storage.type=metadata</span><br><span class="line"></span><br><span class="line">druid.indexer.runner.pendingTasksRunnerNumThreads=5</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/middleManager/runtime.properties</span><br><span class="line">druid.host=node007225</span><br><span class="line">druid.port=8092</span><br><span class="line">druid.service=druid/tranquility/middlemanager</span><br><span class="line"></span><br><span class="line"># Number of tasks per middleManager</span><br><span class="line">druid.worker.capacity=10</span><br><span class="line"></span><br><span class="line"># Task launch parameters</span><br><span class="line">druid.indexer.runner.javaOpts=-server -Xmx4g -XX:MaxDirectMemorySize=10g -Dhadoop.mapreduce.job.classloader=true -Duser.timezone=GMT+8 -Dfile.encoding=UTF-8 -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+CMSClassUnloadingEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+UseCompressedOops -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70</span><br><span class="line">druid.indexer.task.baseTaskDir=/tmp/druid_indexer/task</span><br><span class="line">druid.indexer.task.restoreTasksOnRestart=true</span><br><span class="line"></span><br><span class="line"># Hadoop indexing</span><br><span class="line">#druid.indexer.task.hadoopWorkingPath=var/druid/hadoop-tmp</span><br><span class="line">druid.indexer.task.defaultHadoopCoordinates=[&quot;org.apache.hadoop:hadoop-client:2.6.0-cdh5.12.0&quot;]</span><br><span class="line"></span><br><span class="line"># Peon properties</span><br><span class="line">#druid.indexer.fork.property.druid.monitoring.monitors=[&quot;com.metamx.metrics.JvmMonitor&quot;]</span><br><span class="line">druid.indexer.fork.property.druid.segmentCache.locations=[&#123;&quot;path&quot;: &quot;/tmp/druid_indexer/persistent/zk_druid&quot;, &quot;maxSize&quot;: 0&#125;]</span><br><span class="line">druid.indexer.fork.property.druid.processing.numThreads=4</span><br><span class="line">druid.indexer.fork.property.druid.processing.buffer.sizeBytes=1073741824</span><br><span class="line">druid.indexer.fork.property.druid.server.http.numThreads=100</span><br><span class="line">druid.indexer.fork.property.druid.storage.type=hdfs</span><br><span class="line">druid.indexer.fork.property.druid.storage.storageDirectory=hdfs://192.168.7.233:9000/druid/prod/v1</span><br><span class="line">druid.worker.ip=node007225</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/coordinator/runtime.properties</span><br><span class="line"># Default host: localhost. Default port: 8081. If you run each node type on its own node in production, you should override these values to be IP:8080</span><br><span class="line">druid.host=node007225</span><br><span class="line">druid.port=8081</span><br><span class="line">druid.service=druid/tranquility/coordinator</span><br><span class="line"></span><br><span class="line"># The coordinator begins assignment operations after the start delay.</span><br><span class="line"># We override the default here to start things up faster for examples.</span><br><span class="line"># In production you should use PT5M or PT10M</span><br><span class="line">druid.coordinator.startDelay=PT5M</span><br><span class="line"></span><br><span class="line">druid.selectors.indexing.serviceName=druid/tranquility/indexer</span><br><span class="line">druid.selectors.coordinator.serviceName=druid/tranquility/coordinator</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/historical/runtime.properties</span><br><span class="line">#Nodes Configs</span><br><span class="line">druid.host=node007225</span><br><span class="line">druid.port=8093</span><br><span class="line">druid.service=druid:tranquility:historical</span><br><span class="line"></span><br><span class="line">#General Configuration</span><br><span class="line">druid.server.maxSize=32985348833280</span><br><span class="line"></span><br><span class="line">#druid.server.maxSize=5497558138880</span><br><span class="line">druid.processing.numThreads=24</span><br><span class="line">#Storing Segments</span><br><span class="line">druid.segmentCache.locations=[&#123;&quot;path&quot;:&quot;/DATA1/druid/indexCache&quot;,&quot;maxSize&quot;:3298534883328&#125;]</span><br><span class="line">druid.segmentCache.numLoadingThreads=3</span><br><span class="line"></span><br><span class="line">#Cache</span><br><span class="line">druid.historical.cache.useCache=true</span><br><span class="line">druid.historical.cache.populateCache=true</span><br><span class="line">druid.cache.sizeInBytes=4368709120</span><br><span class="line"></span><br><span class="line">#Query Configs</span><br><span class="line">druid.server.http.numThreads=20</span><br><span class="line">druid.query.groupBy.maxResults=20000000</span><br><span class="line">[xxxx@xxxx druid]$ cat conf/druid/broker/runtime.properties</span><br><span class="line">druid.host=node007225</span><br><span class="line">druid.port=8082</span><br><span class="line">druid.service=druid:tranquility:broker</span><br><span class="line"></span><br><span class="line"># HTTP server threads</span><br><span class="line">druid.broker.http.numConnections=5</span><br><span class="line">druid.server.http.numThreads=25</span><br><span class="line"></span><br><span class="line"># Processing threads and buffers</span><br><span class="line">druid.processing.buffer.sizeBytes=536870912</span><br><span class="line">druid.processing.numThreads=7</span><br><span class="line"></span><br><span class="line"># Query cache</span><br><span class="line">druid.broker.cache.useCache=true</span><br><span class="line">druid.broker.cache.populateCache=true</span><br></pre></td></tr></table></figure><h1><span id="star_tasksh">star_task.sh</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DRUID_HOME=/usr/local/datacenter/druid</span><br><span class="line">LORD_CONF=$DRUID_HOME/conf/druid/overlord</span><br><span class="line"></span><br><span class="line">HADOOP_HOME=/usr/local/datacenter/hadoop</span><br><span class="line">#hadoop_classpath=$HADOOP_HOME/etc/hadoop*</span><br><span class="line">hadoop_classpath=$HADOOP_HOME/etc/hadoop:$HADOOP_HOME/share/hadoop/common/lib/*:$HADOOP_HOME/share/hadoop/common/*:$HADOOP_HOME/share/hadoop/hdfs:$HADOOP_HOME/share/hadoop/hdfs/lib/*:$HADOOP_HOME/share/hadoop/hdfs/*:$HADOOP_HOME/share/hadoop/yarn/lib/*:$HADOOP_HOME/share/hadoop/yarn/*:$HADOOP_HOME/share/hadoop/mapreduce/lib/*:$HADOOP_HOME/share/hadoop/mapreduce/*:$HADOOP_HOME/lib/native/Linux-amd64-64/*</span><br><span class="line">#hadoop_classpath=$HADOOP_HOME/etc/hadoop</span><br><span class="line"></span><br><span class="line">nohup java \</span><br><span class="line"> -Xmx512m -Xms512m -Dfile.encoding=UTF-8 -Duser.timezone=Asia/Shanghai \</span><br><span class="line"> -classpath $DRUID_HOME/conf/druid/overlord:$&#123;hadoop_classpath&#125;:$DRUID_HOME/conf/druid/_common:$DRUID_HOME/lib:$DRUID_HOME/druid-services-0.12.1-selfcontained.jar io.druid.cli.Main index hadoop --coordinate &quot;org.apache.hadoop:hadoop-client:2.6.0-cdh5.12.0&quot;  --no-default-hadoop $DRUID_HOME/web_proxy_templete 2&gt;&amp;1 &gt; /tmp/druid_log/task.log &amp;</span><br></pre></td></tr></table></figure><h2><span id="web_proxy_templete">web_proxy_templete</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;:&quot;index_hadoop&quot;,</span><br><span class="line">    &quot;spec&quot;:&#123;</span><br><span class="line">        &quot;dataSchema&quot;:&#123;</span><br><span class="line">            &quot;dataSource&quot;:&quot;web_proxy_log&quot;,</span><br><span class="line">            &quot;parser&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;hadoopyString&quot;,</span><br><span class="line">                &quot;parseSpec&quot;:&#123;</span><br><span class="line">                    &quot;format&quot;:&quot;json&quot;,</span><br><span class="line">                    &quot;timestampSpec&quot;:&#123;</span><br><span class="line">                        &quot;column&quot;:&quot;basic.time_iso8601&quot;,</span><br><span class="line">                        &quot;format&quot;:&quot;auto&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;dimensionsSpec&quot;:&#123;</span><br><span class="line">                        &quot;dimensions&quot;:[</span><br><span class="line">                            &quot;basic.appname&quot;,</span><br><span class="line">                            &quot;basic.status&quot;,</span><br><span class="line">                            &quot;basic.entrance&quot;,</span><br><span class="line">                            &quot;basic.idc&quot;,</span><br><span class="line">                            &quot;basic.cdn&quot;,</span><br><span class="line">                            &quot;basic.request_path_pattern&quot;,</span><br><span class="line">                            &quot;basic.app_code&quot;,</span><br><span class="line">                            &quot;basic.event_code&quot;</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;dimensionExclusions&quot;:[</span><br><span class="line"></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;metricsSpec&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;count&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;count&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;thetaSketch&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;uuid&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.uuid&quot;,</span><br><span class="line">                    &quot;size&quot;:67108864</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;thetaSketch&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;uid&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.mfw_uid&quot;,</span><br><span class="line">                    &quot;size&quot;:67108864</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;thetaSketch&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;client_ip&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.client_ip&quot;,</span><br><span class="line">                    &quot;size&quot;:67108864</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;doubleSum&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;body_bytes_sent&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.body_bytes_sent&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;doubleSum&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;request_time&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.request_time&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;:&quot;doubleSum&quot;,</span><br><span class="line">                    &quot;name&quot;:&quot;upstream_response_time&quot;,</span><br><span class="line">                    &quot;fieldName&quot;:&quot;basic.upstream_response_time&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;granularitySpec&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;uniform&quot;,</span><br><span class="line">                &quot;segmentGranularity&quot;:&quot;HOUR&quot;,</span><br><span class="line">                &quot;queryGranularity&quot;:&quot;MINUTE&quot;,</span><br><span class="line">                &quot;intervals&quot;:[</span><br><span class="line">                    &quot;2018-08-27T00:00:00+08:00/2018-08-27T00:59:59+08:00&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ioConfig&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;hadoop&quot;,</span><br><span class="line">            &quot;inputSpec&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;granularity&quot;,</span><br><span class="line">                &quot;dataGranularity&quot;:&quot;HOUR&quot;,</span><br><span class="line">                &quot;inputPath&quot;:&quot;hdfs://192.168.7.233:9000/batch_druid/web_proxy/&quot;,</span><br><span class="line">                &quot;pathFormat&quot;:&quot;&apos;dt&apos;=20180827/&apos;hour=00&apos;&quot;,</span><br><span class="line">                &quot;filePattern&quot;:&quot;.*part.*&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;tuningConfig&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;hadoop&quot;,</span><br><span class="line">            &quot;jobProperties&quot;:&#123;</span><br><span class="line">                &quot;mapreduce.job.reduces&quot;:2,</span><br><span class="line">                &quot;mapreduce.job.queuename&quot;:&quot;druid&quot;,</span><br><span class="line">                &quot;mapreduce.task.timeout&quot;:1200000</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;partitionsSpec&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;hashed&quot;,</span><br><span class="line">                &quot;numShards&quot;:5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[dongli</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之设计依据</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E8%AE%BE%E8%AE%A1%E4%BE%9D%E6%8D%AE/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E8%AE%BE%E8%AE%A1%E4%BE%9D%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>Druid在数据摄入与查询的性能方面，做到了很好结合，本章节将详细分析Druid是如何做到的。</p><p>常见的文件组织方式<br>除了内存数据库之外的大多数数据库，数据基本都是存在磁盘上，而磁盘的访问操作相对于内存操作而言是非常耗时的操作，提高数据库性能的关键点之一就是减少对磁盘的访问次数。</p><p>为了减少访问次数，每个数据库基本都有自己特殊的数据结构来帮助提高查询效率（也可以叫索引），考虑到数据查询一般都是一个范围的数据，所以相关结构一般都不会考虑使用HASH结构，而会使用Tree结构，下面对几种常见的Tree结构进行简单的说明</p><h1><span id="二叉查找树binary-search-tree">二叉查找树(Binary Search Tree)</span></h1><p>就是一颗二叉有序树，保证左子树上的所有节点都小于根节点，保证右子树上的所有节点都大于根节点。优点是简单，缺点是出现数据倾斜时，效率会很低</p><h1><span id="平衡二叉树">平衡二叉树</span></h1><p>针对二叉查找树的问题，平衡二叉树出现了，该种树结构的缺点是树高为Log2N,树的高度越高，查找效率越低</p><h1><span id="b树">B+树</span></h1><p>在传统的关系数据库中，B+树以及其衍生树是被用来作为索引数据结构最多的书，特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。详细介绍请参考：&lt;高性能MySql进化论(六):常见索引类型的原理及其特点的介绍&gt; <a href="http://blog.csdn.net/eric_sunah/article/details/14045991：" target="_blank" rel="noopener">http://blog.csdn.net/eric_sunah/article/details/14045991：</a></p><p>B+树的缺点来自于其优点，当存储数据为亿级别时，随着插入操作的不断产生，叶子节点会慢慢的分裂，可能导致原本连续存放的数据，存放在不同的物理磁盘块位置上，做范围查询时，导致较高的磁盘IO,导致性能下降</p><h1><span id="日志合并树lsm">日志合并树（LSM）</span></h1><p>对于写操作而言，顺序写的效率会远远大于随机写的速度，而上述的B+树就违反了该原则。</p><p>1992年日志结构(Log Structured)的新型索引结构产生了，该种类型的思想主要是将磁盘看成是一个大的日志，每次数据都最佳到末端，从而提高了写的性能。此时的日志结构索引对于随机读取的效率很低。</p><p>1996年，日志结构合并树(Log structured Merge-Tree-LSM)的索引结构被提出。该种结构包含了LS的优点，同时又通过将数据文件预排序来克服随机查性能不足的问题。</p><p>LSM的名声大噪归功于HBASE以及Cassandra,随着这两个Apache顶级项目的发展,LSM技术也在不断的发展</p><p>LSM-tree是由两个或两个以上存储数据的结构组成的。最简单的LSM-tree由两个部件构成。一个部件常驻内存，称为C0树（或C0），可以为任何方便键值查找的数据结构，另一个部件常驻硬盘之中，称为C1树（或C1），其数据结构与B-tree类似。C1中经常被访问的结点也将会被缓存在内存中。如下图所示： </p><p><img src="/images/pasted-45.png" alt="upload successful"><br>当插入一条新的数据条目时，首先会向日志文件中写入插入操作的日志，为以后的恢复做准备。然后将根据新条目的索引值将新条目插入到C0中。将新条目插入内存的C0中，不需要任何与硬盘的I/O操作，但内存的存储代价比硬盘的要高上不少，因此当C0的大小达到某一阈值时，内存存储的代价会比硬盘的I/O操作和存储代价还高。故每当C0的大小接近其阈值时，将有一部分的条目从C0滚动合并到硬盘中的C1，以减少C0的大小，降低内存存储数据的代价。</p><p>除了C0,C1结构，LSM Tree通常还会结合日志文件(commit log,在Hbase中叫Hlog)来为数据恢复做保障，C0,C1,commit log的协作顺序大概为：</p><ol><li>新插入的数据首先写到commit log中，该操作叫WAL(Write Ahead LOG)</li><li>写完commit log后，数据写到C0</li><li>打到一定条件后，C0中的数据被Flush到C1，并删除对应的commit log</li><li>C0,C1数据可同时提供查询</li><li>当c0数据出问题了，可以使用commit log与c1中的内容回复C0<br>LSM-Tree的结构非常有利于海量数据的写入，但是在查询方面还是存在不足，为了解决查询性能问题，一般采用如下策略进行弥补： </li><li>定期的对C1上的小的文件进行合并。 </li><li>对C1使用布隆过滤器，以加速查询数据是否在某个C1中的判定。</li></ol><h1><span id="druid中的lsm-tree">Druid中的LSM-Tree</span></h1><p>LSM-Tree适合哪种写操作要远远大于DELETE/UPDATE/QUERY的应用场景，这正好符合Druid的使用场景，所以Druid的文件组织方式与LSM-Tree类似。</p><p>对于可以摄取实时数据的实时节点而言，涉及操作大致如下： </p><ol><li>实时数据首先会被加载到实时节点内存中的堆结构缓冲区 </li><li>当条件满足时，缓冲区的数据会被flush到磁盘上变成一个数据块 </li><li>将磁盘上的数据块加载到内存中的非堆区 </li><li>查询节点可以同时从堆缓冲区与非堆区进行数据查询</li></ol><p>上述描述，可以用下面的图来进行表示: </p><p><img src="/images/pasted-46.png" alt="upload successful"><br>对于已经落地到实时节点的磁盘的数据块，还会进行如下处理： </p><ol><li>实时节点周期性的将统一时间段内的数据块文件合并成一个大的文件 </li><li>生成好的大文件会立即被上传到Deep Storage </li><li>协调节点感知到有新的数据块文件被上传到DeepStorage后，会协调某个历史节点对相关文件进行下载 </li><li>历史节点加载完相关数据后，会通过协调节点对外声明对于该文件内容的查询，都由自己提供。产生该文件的实时节点也会对外声明，不再负责对应数据的查询</li></ol><p>从上述内容可以看出，Druid的类LSM-Tree结构有以下特点： </p><ol><li>类LSM-Tree的架构，保证了Druid的高性能写入 </li><li>通过“查询职责分离模式+不支持更新操作” 保证了组件职责的单一以及数据处理的简单性，保证了查询性能的高效性<h1><span id="druid中的datasource">Druid中的Datasource</span></h1>Druid中的Datasource可以理解为RDBMS中的表，其包含下面三个重要的概念： </li><li>时间列(Timestamp):每行数据的时间值，默认使用UTC时间格式，保存到毫秒级别，本列是数据聚合以及范围查询的重要指标 </li><li>维度列（Dimension）：标识数据行的列，可以是一列，也可以是多列 </li><li>指标列(Metric):用来做计算或是统计的列，可以是一列，也可以是多列</li></ol><p>相对于其他数据库，Druid Datasource最大的特点是在输入存储时，就可以对数据进行聚合操作，该特性不仅可以节省存储的空间，而且可以提高聚合查询的效率。</p><h1><span id="druid中的segment">Druid中的segment</span></h1><p>Segment为Druid中数据的物理存储格式，Segment通过以下特性来支撑Druid的高性能:</p><ol><li>数据的横向切割：横向切割主要只指站在时间范围的角度，将不同时间段的数据存储在不同的Segment文件中(时间范围可以通过segmentGranularity进行设置)，查询时只需要更具时间条件遍历对应的Segment文件即可。</li><li>数据的纵向切割：面向列进行进行数据压缩</li><li>使用BitMap等技术对数据访问进行优化</li></ol><p>参考：<br><a href="https://blog.csdn.net/eric_sunah/article/details/78563634" target="_blank" rel="noopener">druid架构设计</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之实时节点</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%AE%9E%E6%97%B6%E8%8A%82%E7%82%B9/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%AE%9E%E6%97%B6%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#tranquility">Tranquility</a></li></ul><!-- tocstop --><p>实时节点主要负责实时数据摄入，以及生成Segment文件。主要分为三种情况：   </p><ol><li>firehose</li><li>Tranquility</li><li>kafka-index-service   </li></ol><h1><span id="tranquility">Tranquility</span></h1><p>使用Tranquility+Index Service的方式对Kafka的数据进行精确的消费与备份。由于Tranquility可以通过Push的方式将制定的数据推到Druid集群，一次它可以对同一个Partition数据创建多个副本，当某个数据消费任务失败时，系统可以准确的使用另外一个相同任务所创建的Segment数据块。</p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之Indexing Service索引服务</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BIndexing-Service%E7%B4%A2%E5%BC%95%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BIndexing-Service%E7%B4%A2%E5%BC%95%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#主从结构的架构">主从结构的架构</a></li><li><a href="#统治节点overload">统治节点(Overload)</a></li><li><a href="#middlemanager">MiddleManager</a></li><li><a href="#peon">Peon</a></li></ul><!-- tocstop --><p>索引服务也可以产生Segment文件，<strong>相对于实时节点</strong>，索引节点主要包括以下优点： </p><ol><li>除了支持Pull的方式摄取数据，还支持Push的方式 </li><li>可以通过API的方式定义任务配置 </li><li>可以更灵活的使用系统资源 </li><li>可以控制segment副本数量的控制 </li><li>可以灵活的完成和segment数据文件相关的操作 </li><li>提供可扩展以及高可用的特性</li></ol><h1><span id="主从结构的架构">主从结构的架构</span></h1><p>Indexing Service是高可用、分布式、Master/Slave架构服务。主要由三类组件构成：负责运行索引任务(indexing task)的Peon，负责控制Peon的MiddleManager，负责任务分发给MiddleManager的Overlord；三者的关系可以解释为：Overlord是MiddleManager的Master，而MiddleManager又是Peon的Master。其中，Overlord和MiddleManager可以分布式部署，但是Peon和MiddleManager默认在同一台机器上，架构图如下：</p><p><img src="/images/pasted-44.png" alt="upload successful"></p><h1><span id="统治节点overload">统治节点(Overload)</span></h1><p>Overlord负责接受任务、协调任务的分配、创建任务锁以及收集、返回任务运行状态给调用者。当集群中有多个Overlord时，则通过选举算法产生Leader，其他Follower作为备份。</p><p>Overlord可以运行在local（默认）和remote两种模式下，如果运行在local模式下，则Overlord也负责Peon的创建与运行工作，当运行在remote模式下时，Overlord和MiddleManager各司其职，根据上图所示，Overlord接受实时/批量数据流产生的索引任务，将任务信息注册到Zookeeper的/task目录下所有在线的MiddleManager对应的目录中，由MiddleManager去感知产生的新任务，同时每个索引任务的状态又会由Peon定期同步到Zookeeper中/Status目录，供Overlord感知当前所有索引任务的运行状况。</p><p>Overlord对外提供可视化界面，通过访问http://:/console.html，我们可以观察到集群内目前正在运行的所有索引任务、可用的Peon以及近期Peon完成的所有成功或者失败的索引任务。</p><h1><span id="middlemanager">MiddleManager</span></h1><p>MiddleManager负责接收Overlord分配的索引任务，同时创建新的进程用于启动Peon来执行索引任务，每一个MiddleManager可以运行多个Peon实例。</p><p>在运行MiddleManager实例的机器上，我们可以在${ java.io.tmpdir}目录下观察到以XXX_index_XXX开头的目录，每一个目录都对应一个Peon实例；同时restore.json文件中保存着当前所有运行着的索引任务信息，一方面用于记录任务状态，另一方面如果MiddleManager崩溃，可以利用该文件重启索引任务。</p><h1><span id="peon">Peon</span></h1><p>Peon是Indexing Service的最小工作单元，也是索引任务的具体执行者，所有当前正在运行的Peon任务都可以通过Overlord提供的web可视化界面进行访问</p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之Coordinator协调节点</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BCoordinator%E5%8D%8F%E8%B0%83%E8%8A%82%E7%82%B9/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BCoordinator%E5%8D%8F%E8%B0%83%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#历史节点负载均衡">历史节点负载均衡</a></li><li><a href="#数据生命周期">数据生命周期</a></li><li><a href="#replication">Replication</a></li><li><a href="#高可用">高可用</a></li></ul><!-- tocstop --><h1><span id="历史节点负载均衡">历史节点负载均衡</span></h1><p>在典型的生产环境中，查询通常会触及几十个甚至几百个Segment 。由于每个历史节点都资源有限，所以必须在集群中均衡的分配Segment。均衡的策略主要基于成本的优化，例如考虑时间和大小，远近等因素。</p><p>对于历史节点而言，协调节点就是其Master节点，协调节点出问题时，历史节点虽然还可以提供查询功能，但不会再接收新的segment数据。</p><h1><span id="数据生命周期">数据生命周期</span></h1><p>Druid利用针对每个DataSource设置的Rule来加载或丢弃具体的数据文件。规则用来表名表明应该如何分配Segment到不同的历史节点层，以及一个分段的在每个层应该有多少个副本等。规则还可以用来指定什么时候应该删除那些Segment。</p><p>可以对一个Datasource添加多条规则，对于某个Segment来说，协调节点会逐条检查规则，当检测到某个Segment符合某个规则时，就命令对应的历史节点执行对应的操作。</p><h1><span id="replication">Replication</span></h1><p>Druid允许用户指定某个Datasource的Segment副本数，默认为1，即对于某个datasource的某个segment,只会存在于单个历史节点上。 为了防止某个历史节点宕机时，部分segment的不可用，可以根据资源的情况增加segment的副本数。</p><h1><span id="高可用">高可用</span></h1><p>可以通过部署多个协调节点来达到协调节点高可用的目的，如果集群中存在多个Coordinator Node，则通过选举算法产生Leader，其他Follower作为备份。</p>]]></content>
      
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之Broker查询节点</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BBroker%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B9%8BBroker%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#高可用">高可用</a></li></ul><!-- tocstop --><p>Druid提供了两类介质提供Cache功能： </p><ol><li>外部Cache,例如Memcache </li><li>内部Cache,使用查询节点或是历史节点的内存</li></ol><p>Broker Node默认使用LRU缓存策略，查询的时候会首先访问Cache，如果Cache没有命中，才会继续访问历史/实时节点。</p><p>对于每次查询的结果，Historical Node返回的结果，Broker Node认为是“可信的”，会缓存下来，而Real-Time Node返回的实时数据，Broker Node认为是可变的，“不可信的”，所以不会缓存。所以对每个查询请求，如果涉及到实时节点，则该请求总是会转到实时节点。</p><p>Cache也可以理解为对数据额外的备份，即使说有的历史节点都挂了，还是有可能从Cache中查到对应的数据。</p><p>Cache的原理图如下： </p><p><img src="/images/pasted-43.png" alt="upload successful"></p><h1><span id="高可用">高可用</span></h1><p>可以通过Nginx+（N*Broker Node）的方式达到查询节点高可用的效果，该种部署模式下，无论查询请求落到哪个查询节点，返回的结果都是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid部署之historical历史节点</title>
      <link href="/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B8%80/"/>
      <url>/2019/04/28/druid%E9%83%A8%E7%BD%B2%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#内存方式提供查询">内存方式提供查询</a></li><li><a href="#历史节点的分层">历史节点的分层</a></li><li><a href="#历史节点的高可用">历史节点的高可用</a></li></ul><!-- tocstop --><p>历史节点的职责比较单一，主要是将segment数据文件加载到内存以提供数据查询，由于Druid不支持数据变更，因此历史节点就是加载文件与提供查询。</p><h1><span id="内存方式提供查询">内存方式提供查询</span></h1><hr><ol><li>Coordinator Nodes会定期（默认为1分钟）去同步元信息库，感知新生成的Segment，将待加载的Segment信息保存在Zookeeper中</li><li>当Historical Node感知到需要加载新的Segment时，首先会去本地磁盘目录下查找该Segment是否已下载，如果没有，则会从Zookeeper中下载待加载Segment的元信息，此元信息包括Segment存储在何处、如何解压以及如何如理该Segment</li><li>Historical Node使用内存文件映射方式将index.zip中的XXXXX.smoosh文件加载到内存中，并在Zookeeper中本节点的served segments目录下声明该Segment已被加载，从而该Segment可以被查询</li><li>对于重新上线的Historical Node，在完成启动后，也会扫描本地存储路径，将所有扫描到的Segment加载如内存，使其能够被查询。</li><li>无论何种查询，历史节点都会先将segment数据加载到内存，然后再提供查询 </li></ol><p><strong>由于历史节点提供的查询服务依赖于内存，所以内存的大小直接影响到历史节点的性能。</strong></p><h1><span id="历史节点的分层">历史节点的分层</span></h1><hr><p>Druid中，历史节点可以分成不同的层次，相同层次中的所有节点都采用相同的配置。 可以为每一层设置不同的性能和容错参数。   </p><h1><span id="历史节点的高可用">历史节点的高可用</span></h1><hr><p>历史节点拥有较好的高可用特性，协调节点可以通过Zookeeper感知到历史节点的增加或是删除操作。当新增历史节点时，协调可以自动分配Segment给新增的节点，当移除历史节点时，协调节点会将该历史节点上的数据分配给其他处于Active状态的历史节点。</p><p>历史节点依赖于Zookeeper进行Segment数据的加载和卸载操作。如果Zookeeper变得不可用，历史节点将不能再进行数据加载和卸载操作。但是因为查询功能使用的是HTTP服务，所以Zookeeper出现异常后，不会影响历史节点上对以加载数据的查询。</p><p>参考：<br><a href="https://blog.csdn.net/eric_sunah/article/details/78563634" target="_blank" rel="noopener">Druid架构剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase之HFile索引机制二HFile索引结构解析</title>
      <link href="/2019/04/26/HBase%E4%B9%8BHFile%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E4%BA%8C/"/>
      <url>/2019/04/26/HBase%E4%B9%8BHFile%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#索引分层的原因">索引分层的原因</a></li><li><a href="#v2版本index-block有两类">V2版本Index Block有两类</a><ul><li><a href="#root-index-block">Root Index Block</a></li><li><a href="#nonroot-index-block">NonRoot Index Block</a></li></ul></li><li><a href="#hfile数据完整索引流程">HFile数据完整索引流程</a></li><li><a href="#索引块分裂">索引块分裂</a><ul><li><a href="#append流程">Append流程</a></li><li><a href="#finalize阶段">Finalize阶段</a></li></ul></li><li><a href="#总-结">总 结</a></li></ul><!-- tocstop --><h1><span id="索引分层的原因">索引分层的原因</span></h1><hr><p>HFile中索引结构根据索引层级的不同分为两种：single-level和mutil-level，前者表示单层索引，后者表示多级索引，一般为两级或三级。HFile V1版本中只有single-level一种索引结构，V2版本中引入多级索引。之所以引入多级索引，是因为随着HFile文件越来越大，Data Block越来越多，索引数据也越来越大，已经无法全部加载到内存中（V1版本中一个Region Server的索引数据加载到内存会占用几乎6G空间），多级索引可以只加载部分索引，降低内存使用空间。上一篇文章 《HBase-存储文件HFile结构解析》，我们提到Bloom    Filter内存使用问题是促使V1版本升级到V2版本的一个原因，再加上这个原因，这两个原因就是V1版本升级到V2版本最重要的两个因素。     </p><h1><span id="v2版本index-block有两类">V2版本Index Block有两类</span></h1><hr><p>分为Root Index Block和NonRoot Index Block，其中NonRoot Index Block又分为Intermediate Index Block和Leaf Index Block两种。HFile中索引结构类似于一棵树，Root Index Block表示索引数根节点，Intermediate Index Block表示中间节点，Leaf Index block表示叶子节点，叶子节点直接指向实际数据块。</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p>HFile中除了Data Block需要索引之外，上一篇文章提到过Bloom Block也需要索引，索引结构实际上就是采用了single-level结构，文中<strong>Bloom Index Block就是一种Root Index Block</strong>。</p><p>对于Data Block，<strong>由于HFile刚开始数据量较小，索引采用single-level结构，只有Root Index一层索引，直接指向数据块。当数据量慢慢变大，Root Index Block满了之后，索引就会变为mutil-level结构，由一层索引变为两层，根节点指向叶子节点，叶子节点指向实际数据块。如果数据量再变大，索引层级就会变为三层</strong>。</p><p>下面就针对Root index Block和NonRoot index Block两种结构进行解析，因为Root Index Block已经在上面一篇文章中分析过， 此处简单带过，重点介绍NonRoot Index Block结构（InterMediate Index Block和Ieaf Index Block在内存和磁盘中存储格式相同，都为NonRoot Index Block格式）。</p><h2><span id="root-index-block">Root Index Block</span></h2><p>Root Index Block表示索引树根节点索引块，可以作为bloom的直接索引，也可以作为data索引的根索引。而且对于single-level 和mutil-level两种索引结构对应的Root Index Block略有不同，<strong>本文以mutil-level索引结构为例进行分析（single-level索引结构是mutual-level的一种简化场景）</strong>，在内存和磁盘中的格式如下图所示：   </p><p><img src="/images/pasted-37.png" alt="upload successful"><br>其中Index Entry表示具体的索引对象，每个索引对象由3个字段组成    </p><ol><li>Block Offset表示索引指向数据块的偏移量</li><li>BlockDataSize 表示索引指向数据块在磁盘上的大小</li><li>BlockKey表示索引指向数据块中的第一个key</li><li>除此之外，还有另外3个字段用来记录MidKey的相关信息，<strong>MidKey表示HFile所有Data Block中中间的一个Data Block，用于在对HFile进行split操作时，快速定位HFile的中间位置</strong>。  </li></ol><p><strong>需要注意的是single-level索引结构和mutil-level结构相比，就只缺少MidKey这三个字段</strong>。</p><p>Root Index Block会在HFile解析的时候直接加载到内存中，此处需要注意在Trailer Block中有一个字段为dataIndexCount，就表示此处Index Entry的个数。因为Index Entry并不定长，只有知道Entry的个数才能正确的将所有Index Entry加载到内存。</p><h2><span id="nonroot-index-block">NonRoot Index Block</span></h2><p>当HFile中Data Block越来越多，single-level结构的索引已经不足以支撑所有数据都加载到内存，需要分化为mutil-level结构。mutil-level结构中NonRoot Index Block作为中间层节点或者叶子节点存在，无论是中间节点还是叶子节点，其都拥有相同的结构，如下图所示：</p><p><img src="/images/pasted-38.png" alt="upload successful"><br>和Root Index Block相同，NonRoot Index Block中最核心的字段也是Index Entry，用于指向叶子节点块或者数据块。<strong>不同的是，NonRoot Index Block结构中增加了block块的内部索引entry Offset字段</strong>，entry Offset表示index Entry在该block中的相对偏移量（相对于第一个index Entry)，用于实现block内的二分查找。所有非根节点索引块，包括Intermediate index block和leaf index block，在其内部定位一个key的具体索引并不是通过遍历实现，<strong>而是使用二分查找算法</strong>，这样可以更加高效快速地定位到待查找key。</p><h1><span id="hfile数据完整索引流程">HFile数据完整索引流程</span></h1><p>了解了HFile中数据索引块的两种结构之后，就来看看如何使用这些索引数据块进行数据的高效检索。整个索引体系类似于MySQL 的B+树结构，但是又有所不同，比B+树简单，并没有复杂的分裂操作。具体见下图所示：</p><p><img src="/images/pasted-39.png" alt="upload successful"></p><p>图中上面三层为索引层，<strong>在数据量不大的时候只有最上面一层，数据量大了之后开始分裂为多层，最多三层</strong>，如图所示。最下面一层为数据层，存储用户的实际keyvalue数据。这个索引树结构类似于InnoSQL的聚集索引，只是HBase并没有辅助索引的概念。  </p><p>图中红线表示一次查询的索引过程（HBase中相关类为HFileBlockIndex和HFileReaderV2）</p><p>基本流程可以表示为：</p><ol><li>用户输入rowkey为fb，在root index block中通过二分查找定位到fb在’a’和’m’之间，因此需要访问索引’a’指向的中间节点。因为root index block常驻内存，所以这个过程很快；<ol start="2"><li>将索引’a’指向的中间节点索引块加载到内存，然后通过二分查找定位到fb在index ‘d’和’h’之间，接下来访问索引’d’指向的叶子节点；</li><li>同理，将索引’d’指向的中间节点索引块加载到内存，一样通过二分查找定位找到fb在index ‘f’和’g’之间，最后需要访问索引’f’指向的数据块节点；</li><li>将索引’f’指向的数据块加载到内存，通过遍历的方式找到对应的keyvalue。</li></ol></li></ol><p>上述流程中因为<strong>中间节点、叶子节点和数据块都需要加载到内存，所以io次数正常为3次</strong>。但是实际上HBase为block提供了缓存机制，可以将频繁使用的block缓存在内存中，可以进一步加快实际读取过程。所以，在HBase中，通常一次随机读请求最多会产生3次io，如果数据量小（只有一层索引），数据已经缓存到了内存，就不会产生io。</p><h1><span id="索引块分裂">索引块分裂</span></h1><p>上文中已经提到，当数据量少、文件小的时候，只需要一个root index block就可以完成索引，即索引树只有一层。当数据不断写入，文件变大之后，索引数据也会相应变大，索引结构就会由single-level变为mulit-level，期间涉及到索引块的写入和分裂，本节来关注一下数据写入是如何引起索引块分裂的。   </p><p>如果大家之前看过HBase系列另一篇博文《HBase数据写入之Memstore Flush》，可以知道memstore flush主要分为3个阶段，  </p><ol><li>第一个阶段会讲memstore中的keyvalue数据snapshot，</li><li>第二阶段再将这部分数据flush的HFile，并生成在临时目录，</li><li>第三阶段将临时文件移动到指定的ColumnFamily目录下。   </li></ol><p>很显然，<strong>第二阶段将keyvalue数据flush到HFile将会是关注的重点</strong>（flush相关代码在DefaultStoreFlusher类中）。整个flush阶段又可以分为两阶段：</p><ol><li>append阶段：memstore中keyvalue首先会写入到HFile中数据块；</li><li>finalize阶段：修改HFlie中meta元数据块，索引数据块以及Trailer数据块等。</li></ol><h2><span id="append流程">Append流程</span></h2><p>具体key value数据的append以及finalize过程在HFileWriterV2文件中，其中append流程可以大体表征为：</p><p><img src="/images/pasted-40.png" alt="upload successful"></p><ol><li>预检查：检查key的大小是否大于前一个key，如果大于则不符合HBase顺序排列的原理，抛出异常；检查value是否是null，如果为null也抛出异常；</li><li>block是否写满：检查当前Data Block是否已经写满，如果没有写满就直接写入keyvalue；否则就需要执行数据块落盘以及索引块修改操作；</li><li><strong>数据落盘并修改索引</strong>：如果DataBlock写满，首先将block块写入流；<strong>再生成一个leaf index entry，写入leaf Index block</strong>；再检查该leaf index block是否已经写满需要落盘，如果已经写满，就将该leaf index block写入到输出流，并且为索引树根节点root index block新增一个索引，指向叶子节点(second-level index)；</li><li>生成一个新的block：重新reset输出流，初始化startOffset为-1； </li><li>写入keyvalue：将keyvalue以流的方式写入输出流，同时需要写入memstoreTS；除此之外，如果该key是当前block的第一个key，需要赋值给变量firstKeyInBlock。</li></ol><h2><span id="finalize阶段">Finalize阶段</span></h2><p>memstore中所有keyvalue都经过append阶段输出到HFile后，会执行一次finalize过程，主要更新HFile中meta元数据块、索引数据块以及Trailer数据块，其中对索引数据块的更新是我们关心的重点，此处详细解析，上述append流程中c步骤’数据落盘并修改索引’会使得root index block不断增多，当增大到一定程度之后就需要分裂，分裂示意图如下图所示：</p><p><img src="/images/pasted-41.png" alt="upload successful"><br>上图所示，分裂前索引结构为second-level结构，图中没有画出Data Blocks，根节点索引指向叶子节点索引块。finalize阶段系统会对Root Index Block进行大小检查，如果大小大于规定的大小就需要进行分裂，图中分裂过程实际上就是将原来的Root Index Block块分割成4块，每块独立形成中间节点InterMediate Index Block，系统再重新生成一个Root Index Block（图中红色部分），分别指向分割形成的4个interMediate Index Block。此时索引结构就变成了third-level结构。</p><h1><span id="总-结">总 结</span></h1><p>这篇文章是HFile结构解析的第二篇文章，主要集中介绍HFile中的数据索引块。<br>①首先分Root Index Block和NonRoot Index Block 两部分对HFile中索引块进行了解析，<br>②紧接着基于此介绍了HBase如何使用索引对数据进行检索，<br>③最后结合Memstore Flush的相关知识分析了keyvalue数据写入的过程中索引块的分裂过程。   </p><p>希望通过这两篇文章的介绍，能够对HBase中数据存储文件HFile有一个更加全面深入的认识。</p>]]></content>
      
      
      <categories>
          
          <category> hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase之HFile索引机制一HFile存储结构</title>
      <link href="/2019/04/26/HBase%E4%B9%8BHFile%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/26/HBase%E4%B9%8BHFile%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#hfile演化">Hfile演化</a></li><li><a href="#hfile-v2的逻辑结构">HFile V2的逻辑结构</a></li><li><a href="#hfile-v2物理结构">HFile v2物理结构</a></li><li><a href="#hfile-v2中核心block块解析">HFile V2中核心Block块解析</a><ul><li><a href="#trailer-block">Trailer Block</a></li><li><a href="#data-block">Data Block</a></li><li><a href="#bloomfilter-meta-block-bloom-block">BloomFilter Meta Block &amp; Bloom Block</a></li></ul></li><li><a href="#总结">总结</a></li></ul><!-- tocstop --><h1><span id="hfile演化">Hfile演化</span></h1><hr><p>HFile是HBase存储数据的文件组织形式，参考BigTable的SSTable和Hadoop的TFile实现。从HBase开始到现在，HFile经历了三个版本，其中V2在0.92引入，V3在0.98引入。HFileV1版本的在实际使用过程中发现它占用内存多，HFile V2版本针对此进行了优化，HFile V3版本基本和V2版本相同，只是在cell层面添加了Tag数组的支持。鉴于此，<strong>本文主要针对V2版本进行分析</strong>，对V1和V3 版本感兴趣的同学可以参考其他信息。    </p><h1><span id="hfile-v2的逻辑结构">HFile V2的逻辑结构</span></h1><hr><p><img src="/images/pasted-26.png" alt="upload successful"><br><img src="/images/pasted-42.png" alt="upload successful"><br>文件主要分为四个部分：</p><ol><li>Scanned block section<br>顾名思义，表示顺序扫描HFile时所有的数据块将会被读取，包括Leaf Index Block和Bloom Block。</li><li>Non-scanned block section<br>表示在HFile顺序扫描的时候数据不会被读取，主要包括Meta Block和Intermediate Level Data Index Blocks两部分。</li><li>Load-on-open-section<br><strong>这部分数据在HBase的region server启动时，需要加载到内存中</strong>。包括root data block index和meta data block index、FileInfo、Bloom filter block。    </li><li>Trailer<br>这部分主要记录了HFile的基本信息、各个部分的偏移值和寻址信息。    <h1><span id="hfile-v2物理结构">HFile v2物理结构</span></h1></li></ol><hr><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>如上图所示，HFlie会被切分为多个大小相等的block块，每个block的大小可以在创建表列簇的时候通过参数blocksize=&gt;’65535‘进行指定，默认为64K，大号的Block有利于顺序Scan，小号Block利于随机查询，因而需要权衡。<br>而且所有block块都拥有相同的数据结构，如图左侧所示，HBase将block块抽象为一个统一的HFileBlock。HFileBlock支持两种类型，一种类型不支持checksum，一种支持。<br>为方便讲解，下图选用<strong>不支持checksum的HFileBlock内部结构</strong>：</p><p><img src="/images/pasted-28.png" alt="upload successful"><br>上图所示HFileBlock主要包括两部分：</p><ol><li>BlockHeader主要存储block元数据<br>block元数据中最核心的字段是BlockType字段，用来标示该block块的类型，HBase中定义了8种BlockType，每种BlockType对应的block都存储不同的数据内容，有的存储用户数据，有的存储索引数据，有的存储meta元数据。对于任意一种类型的HFileBlock， 都拥有相同结构的BlockHeader </li><li>BlockData用来存储具体数据。<br>但是BlockData结构却不相同。下面通过一张表简单罗列最核心的几种BlockType，下文会详细针对每种BlockType进行详细的讲解：<br><img src="/images/pasted-29.png" alt="upload successful"><h1><span id="hfile-v2中核心block块解析">HFile V2中核心Block块解析</span></h1></li></ol><hr><p>上文从HFile的层面将文件切分成了多种类型的block，接下来针对几种重要block进行详细的介绍，因为篇幅的原因，索引相关的block不会在本文进行介绍，接下来会写一篇单独的文章对其进行分析和讲解。①首先会介绍记录HFile基本信息的TrailerBlock，②再介绍用户数据的实际存储块DataBlock，③最后简单介绍布隆过滤器相关的block。   </p><h2><span id="trailer-block">Trailer Block</span></h2><hr><p>TrailerBlock主要记录了HFile的基本信息、各个部分的偏移值和寻址信息，下图为Trailer内存和磁盘中的数据结构，其中只显示了部分核心字段：<br><img src="/images/pasted-30.png" alt="upload successful"><br>HFile在读取的时候<strong>首先会解析Trailer Block并加载到内存，然后再进一步加载LoadOnOpen区的数据</strong>，具体步骤如下：</p><ol><li>首先加载version版本信息，HBase中version包含majorVersion和minorVersion两部分，①前者决定了HFile的主版本：V1、V2 还是V3；②后者在主版本确定的基础上决定是否支持一些微小修正，比如是否支持checksum等。<strong>不同的版本决定了使用不同的Reader对象对HFile进行读取解析</strong></li><li>根据Version信息获取trailer的长度（不同version的trailer长度不同），再根据trailer长度加载整个HFileTrailer Block   </li><li><strong>最后加载load-on-open部分到内存中，①起始偏移地址是trailer中的LoadOnOpenDataOffset字段，load-on-open部分的结束偏移量为HFile长度减去Trailer长度，②load-on-open部分主要包括索引树的根节点以及Filelnfo两个重要模块，Filelnfo是固定长度的block块 ，它纪录了文的一些Meta信息</strong>，例 如 ： AVG_KEY_LEN, AVG_VALUE_LEN, LAST_KEY, COMPARATOR, MAX_SEQ_ID_KEY等；索引树根节点放到下一篇文章进行介绍。</li></ol><h2><span id="data-block">Data Block</span></h2><hr><p>DataBlock 是HBase 中数据存储的最小单元。DataBlock 中主要存储用户的KeyValue 数据（ KeyValue 后面一般会跟一个timestamp ， 图中未标出）， 而KeyValue结构是HBase存储的核心， 每个数据都是以KeyValue结构在HBase中进行存储。KeyValue结构在内存和磁盘中可以表示为：<br><img src="/images/pasted-31.png" alt="upload successful"><br>每个KeyValue都由4个部分构成，分别为key length，value length，key和value。</p><ol><li>key length和value length是两个固定长度的数值</li><li>key是一个复杂的结构<br>①首先是rowkey的长度<br>②接着是rowkey<br>③然后是ColumnFamily的长度<br>④再是ColumnFamily<br>⑤最后是时间戳和KeyType（keytype有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily）</li><li>key是一个复杂的结构①首先是rowkey的长度，②接着是rowkey，③然后是ColumnFamily的长度，再是ColumnFamily， ④最后是时间戳和KeyType（keytype有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily）</li><li>value就没有那么复杂，就是一串纯粹的二进制数据。</li></ol><h2><span id="bloomfilter-meta-block-amp-bloom-block">BloomFilter Meta Block &amp; Bloom Block</span></h2><p><strong>BloomFilter Meta Block在Load-on-open-section中，而Bloom Block是在Scanned block section中</strong>。<br><strong>BloomFilter对于HBase的随机读性能至关重要</strong>，对于get操作以及部分scan操作可以剔除掉不会用到的HFile文件，减少实际IO次数，提高随机读性能。    </p><p>在此简单地介绍一下Bloom Filter的工作原理，Bloom Filter使用位数组来实现过滤，初始状态下位数组每一位都为0，如下图所示：</p><p><img src="/images/pasted-32.png" alt="upload successful"><br>假如此时有一个集合S = {x1, x2, … xn}，Bloom Filter使用<strong>k个独立的hash函数</strong>，分别将集合中的每一个元素映射到｛1,…,m｝的范围。<strong>对于任何一个元素，被映射到的数字作为对应的位数组的索引，该位会被置为1</strong>。比如元素x1被hash函数映射到数字8，那么位数组的第8位就会被置为1。下图中集合S只有两个元素x和y，分别被3个hash函数进行映射，映射到的位置分别为（0，3，6）和（4，7，10），对应的位会被置为1:   </p><p><img src="/images/pasted-33.png" alt="upload successful"><br>现在假如要判断另一个元素是否是在此集合中，只需要被这3个hash函数进行映射，查看对应的位置是否有0存在，如果有的话，表示此元素肯定不存在于这个集合，否则有可能存在。下图所示就表示z肯定不在集合｛x，y｝中：</p><p><img src="/images/pasted-34.png" alt="upload successful"><br><strong>Bloom Filter只要认为不存在就一定不存在，认为存在会可能不存在</strong>    </p><p>HBase中每个HFile都有对应的位数组，<strong>KeyValue在写入HFile时会先经过几个hash函数的映射，映射后将对应的数组位改为1</strong>， get请求进来之后再进行hash映射，如果在对应数组位上存在0，说明该get请求查询的数据不在该HFile中。    </p><p>HFile中的位数组就是上述Bloom Block中存储的值，可以想象，一个HFile文件越大，里面存储的KeyValue值越多，位数组就会相应越大。一旦太大就不适合直接加载到内存了，<strong>因此HFile V2在设计上将位数组进行了拆分，拆成了多个独立的位数组（根据Key进行拆分，一部分连续的Key使用一个位数组）。这样一个HFile中就会包含多个位数组，根据Key进行查询，首先会定位到具体的某个位数组，只需要加载此位数组到内存进行过滤即可，减少了内存开支</strong>。    </p><p><strong>在结构上每个位数组对应HFile中一个Bloom Block，为了方便根据Key定位具体需要加载哪个位数组，HFile V2又设计了对应的索引Bloom Index Block</strong>，对应的内存和逻辑结构图如下：</p><p><img src="/images/pasted-35.png" alt="upload successful"><br>Bloom Index Block结构中</p><ol><li>totalByteSize表示位数组的bit数</li><li>numChunks表示Bloom Block的个数</li><li>hashCount表示hash函数的个数</li><li>hashType表示hash函数的类型</li><li>totalKeyCount表示bloom filter当前已经包含的key的数目</li><li>totalMaxKeys表示bloomfilter当前最多包含的key的数目</li><li>Bloom Index Entry对应每一个bloom filter block的索引条目，<strong>作为索引分别指向’scanned block section’部分的Bloom Block</strong>，Bloom Block中就存储了对应的位数组。</li></ol><p>Bloom Index Entry 的结构见上图左边所示</p><ol><li>BlockOffset 表示对应Bloom Block 在HFile 中的偏移量</li><li>FirstKey 表示对应BloomBlock的第一个Key。</li><li>根据上文所说，一次get请求进来，首先会根据key在所有的索引条目中进行二分查找，查找到对应的Bloom Index Entry，就可以定位到该key对应的位数组，加载到内存进行过滤判断。<h1><span id="总结">总结</span></h1>这篇小文<br>①首先从宏观的层面对HFile的逻辑结构和物理存储结构进行了讲解，<br>②并且将HFile从逻辑上分解为各种类型的Block，<br>③再接着从微观的视角分别对Trailer Block、Data Block在结构上进行了解析：通过对Trailer Block的解析，可以获取HFile的版本以及HFile中其他几个部分的偏移量，在读取的时候可以直接通过偏移量对其进行加载；<br>④而对Data Block的解析可以知道用户数据在HDFS中是如何实际存储的；<br>⑤最后通过介绍Bloom Filter的工作原理以及相关的Block块了解HFile中Bloom Filter的存储结构。</li></ol><p>接下来会以本文为基础，再写一篇文章分析HFile中索引块的结构以及相应的索引机制。</p><p>参考：<br><a href="http://www.cnblogs.com/163yun/p/9020629.html" target="_blank" rel="noopener">文件HFile存储结构解析</a><br><a href="https://www.cnblogs.com/163yun/p/9020539.html" target="_blank" rel="noopener">HBase – 探索HFile索引机制</a></p>]]></content>
      
      
      <categories>
          
          <category> hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hbase问题集锦</title>
      <link href="/2019/04/26/hbase%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
      <url>/2019/04/26/hbase%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<!--  toc --><h1><span id="hbase为什么那么快">hbase为什么那么快？</span></h1><p>应该分为读和写。 </p><ol><li>LSM + compaction    </li><li>HFile索引机制        </li><li>布隆过滤器</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Region寻址</title>
      <link href="/2019/04/26/Region%E5%AF%BB%E5%9D%80/"/>
      <url>/2019/04/26/Region%E5%AF%BB%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#096版本以前的寻址方式">0.96版本以前的寻址方式</a></li><li><a href="#新的region寻址方式">新的Region寻址方式</a></li><li><a href="#总结">总结</a></li></ul><!-- tocstop --><h1><span id="096版本以前的寻址方式">0.96版本以前的寻址方式</span></h1><hr><p>在Hbase 0.96版本以前，Hbase有两个特殊的表，分别是-ROOT-表和.META.表，其中-ROOT-的位置存储在ZooKeeper中，-ROOT-本身存储了 .META. Table的RegionInfo信息，<strong>并且-ROOT-不会分裂，只有一个region。而.META.表可以被切分成多个region</strong>。读取的流程如下图所示：</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p><img src="/images/pasted-24.png" alt="upload successful"><br>寻址步骤： </p><ol><li>client请求ZK获得-ROOT-所在的RegionServer地址   </li><li>client请求-ROOT-所在的RS地址，获取.META.表的地址，client会将-ROOT-的相关信息cache下来，以便下一次快速访问    </li><li>client请求 .META.表的RS地址，获取访问数据所在RegionServer的地址，client会将.META.的相关信息cache下来，以便下一次快速访问    </li><li>client请求访问数据所在RegionServer的地址，获取对应的数据</li></ol><p>从上面的路径我们可以看出，用户需要3次请求才能直到用户Table真正的位置，然后第4次请求开始获取真正的数据,这在一定程序带来了性能的下降。<strong>即最差要四次请求</strong>    </p><p>在0.96之前使用3层设计的主要原因是考虑到元数据可能需要很大。但是真正集群运行，元数据的大小其实很容易计算出来。在BigTable的论文中，每行METADATA数据存储大小为1KB左右，如果按照一个Region为128M的计算，3层设计可以支持的Region个数为2^34个，采用2层设计可以支持2^17（131072）。  </p><p>分析一：<br>如果一个region的大小为128m,那么就说明.META.的大小也为128M。每行METADATA数据存储大小为1KB左右，那么.META.表就可以存储<br>131072 KB = 128M =2^17个region. 此时按照每个region 128m大小，131072*128M = 16T.而且<del>meta表肯定不止一个region，</del>一个region肯定不止128M，所以，从meta来定位的数据大小远大于16T。<br>如果单个region大小设置为2G，那么此时一个meta region就可以容纳4P的数据。<br>分析二：<br>为什么3层设计可以支持的Region个数为2^34个，采用2层设计可以支持2^17？<br>3层则是-ROOT-表128M，其中每1kb的数据存储一张.META.表，总可以存128*1024*128张.meta表即2^34张.   </p><h1><span id="新的region寻址方式">新的Region寻址方式</span></h1><hr><p>如上面的计算，2层结构其实完全能满足业务的需求，因此0.96版本以后将-ROOT-表去掉了。如下图所示：</p><p><img src="/images/pasted-25.png" alt="upload successful"><br>访问步骤：</p><ol><li>Client请求ZK获取.META.所在的RegionServer的地址。   </li><li>Client请求.META.所在的RegionServer获取访问数据所在的RegionServer地址，client会将.META.的相关信息cache下来，以便下一次快速访问。   </li><li>Client请求数据所在的RegionServer，获取所需要的数据。</li></ol><p><strong>访问路径变成了3步</strong>    </p><h1><span id="总结">总结</span></h1><p>总结去掉-ROOT-的原因有如下2点：<br>其一：提高性能<br>其二：2层结构已经足以满足集群的需求<br>这里还有一个问题需要说明，那就是Client会缓存.META.的数据，用来加快访问，既然有缓存，那它什么时候更新？如果.META.更新了，比如Region1不在RerverServer2上了，被转移到了RerverServer3上。client的缓存没有更新会有什么情况？<br>其实，Client的元数据缓存不更新，当.META.的数据发生更新。如上面的例子，由于Region1的位置发生了变化，Client再次根据缓存去访问的时候，会出现错误，当出现异常达到重试次数后就会去.META.所在的RegionServer获取最新的数据，如果.META.所在的RegionServer也变了，Client就会去ZK上获取.META.所在的RegionServer的最新地址。</p><p>参考：<br><a href="https://blog.csdn.net/qq_36421826/article/details/82701677" target="_blank" rel="noopener">https://blog.csdn.net/qq_36421826/article/details/82701677</a><br><a href="https://www.cnblogs.com/qcloud1001/p/7615526.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/7615526.html</a><br><a href="https://www.cnblogs.com/ios1988/p/6266767.html" target="_blank" rel="noopener">https://www.cnblogs.com/ios1988/p/6266767.html</a><br><a href="https://www.cnblogs.com/cenzhongman/p/7271761.html" target="_blank" rel="noopener">https://www.cnblogs.com/cenzhongman/p/7271761.html</a></p>]]></content>
      
      
      <categories>
          
          <category> hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一</title>
      <link href="/2019/04/26/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
      <url>/2019/04/26/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构" target="_blank" rel="noopener">数据结构</a><ul><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列" target="_blank" rel="noopener">队列</a></li><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合" target="_blank" rel="noopener">集合</a></li><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组" target="_blank" rel="noopener">链表、数组</a></li><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组" target="_blank" rel="noopener">字典、关联数组</a></li><li><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈" target="_blank" rel="noopener">栈</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三之BitSet</title>
      <link href="/2019/04/26/BitSet/"/>
      <url>/2019/04/26/BitSet/</url>
      
        <content type="html"><![CDATA[<p>BitSet是位操作的对象，值只有0或1即false和true，内部维护了一个long数组，初始只有一个long，所以BitSet最小的size是64，当随着存储的元素越来越多，BitSet内部会动态扩充，一次扩充64位，最终内部是由N个long来存储。</p><p>默认情况下，BitSet的所有位都是false即0。</p><p>(Java Bitset类)[<a href="http://www.runoob.com/java/java-bitset-class.html]" target="_blank" rel="noopener">http://www.runoob.com/java/java-bitset-class.html]</a><br>(Java BitSet位集)[<a href="https://blog.csdn.net/caiandyong/article/details/51581160]" target="_blank" rel="noopener">https://blog.csdn.net/caiandyong/article/details/51581160]</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void set(int index, boolean v)</span><br><span class="line">将指定索引处的位设置为指定的值。</span><br><span class="line">void set(int index)</span><br><span class="line">将指定索引处的位设置为 true。</span><br></pre></td></tr></table></figure></p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.BitSet;</span><br><span class="line"> </span><br><span class="line">public class BitSetDemo &#123;</span><br><span class="line"> </span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line">     BitSet bits1 = new BitSet(16);</span><br><span class="line">     BitSet bits2 = new BitSet(16);</span><br><span class="line">      </span><br><span class="line">     // set some bits</span><br><span class="line">     for(int i=0; i&lt;16; i++) &#123;</span><br><span class="line">        if((i%2) == 0) bits1.set(i);</span><br><span class="line">        if((i%5) != 0) bits2.set(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(&quot;Initial pattern in bits1: &quot;);</span><br><span class="line">     System.out.println(bits1);</span><br><span class="line">     System.out.println(&quot;\nInitial pattern in bits2: &quot;);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     // AND bits</span><br><span class="line">     bits2.and(bits1);</span><br><span class="line">     System.out.println(&quot;\nbits2 AND bits1: &quot;);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     // OR bits</span><br><span class="line">     bits2.or(bits1);</span><br><span class="line">     System.out.println(&quot;\nbits2 OR bits1: &quot;);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     // XOR bits</span><br><span class="line">     bits2.xor(bits1);</span><br><span class="line">     System.out.println(&quot;\nbits2 XOR bits1: &quot;);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initial pattern in bits1:</span><br><span class="line">&#123;0, 2, 4, 6, 8, 10, 12, 14&#125;</span><br><span class="line"></span><br><span class="line">Initial pattern in bits2:</span><br><span class="line">&#123;1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14&#125;</span><br><span class="line"></span><br><span class="line">bits2 AND bits1:</span><br><span class="line">&#123;2, 4, 6, 8, 12, 14&#125;</span><br><span class="line"></span><br><span class="line">bits2 OR bits1:</span><br><span class="line">&#123;0, 2, 4, 6, 8, 10, 12, 14&#125;</span><br><span class="line"></span><br><span class="line">bits2 XOR bits1:</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>通常不直接使用原生的bitmap，而使用RoaringBitmap，它的压缩比更好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line">       RoaringBitmap r1 = new RoaringBitmap();</span><br><span class="line">   r1.add(1);//表示将索引为1的位置置为1</span><br><span class="line">   r1.add(0);//表示将索引为0的位置置为1</span><br><span class="line">   r1.add(6);//表示将索引为6的位置置为1</span><br><span class="line">       RoaringBitmap r2 = new RoaringBitmap();</span><br><span class="line">       r2.add(0);//表示将索引为1的位置置为1</span><br><span class="line">       r2.add(6);//表示将索引为6的位置置为1</span><br><span class="line"></span><br><span class="line">   RoaringBitmap and = RoaringBitmap.and(r1, r2);</span><br><span class="line">   System.out.println(and.toString());//得到的是共同元素索引的位置</span><br><span class="line">   System.out.println(and.getCardinality());</span><br></pre></td></tr></table></figure></p><p>druid也是使用该方式实现的底层模块。<br>(使用方案)[<a href="https://juejin.im/post/5b4ea9625188251b381269e6]" target="_blank" rel="noopener">https://juejin.im/post/5b4ea9625188251b381269e6]</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二之树</title>
      <link href="/2019/04/26/%E6%A0%91/"/>
      <url>/2019/04/26/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#为什么要有二叉树">为什么要有二叉树?</a></li><li><a href="#完全二叉树">完全二叉树</a></li><li><a href="#二叉查找树bst">二叉查找树(BST)</a></li><li><a href="#平衡二叉树">平衡二叉树</a><ul><li><a href="#2-3查找树2-3-search-tree">2-3查找树(2-3 Search Tree)</a></li></ul></li><li><a href="#红黑树">红黑树</a></li><li><a href="#b树b树b树">B树，B+树，B*树</a><ul><li><a href="#b树是一种多路搜索树并不一定是二叉的">B树是一种多路搜索树（并不一定是二叉的）</a></li><li><a href="#b树">B+树</a><ul><li><a href="#b树-vs-b树">B+树 VS B树</a></li></ul></li><li><a href="#b树">B*树</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#lsm树">LSM树</a><ul><li><a href="#复习b树">复习B+树</a></li><li><a href="#lsm树-1">LSM树</a></li><li><a href="#lsm在hbase中的使用">LSM在HBase中的使用</a></li></ul></li></ul><!-- tocstop --><p>树的概念咱们就直接跳过了。    </p><h1><span id="为什么要有二叉树">为什么要有二叉树?</span></h1><hr><p>在实际使用时会根据链表和有序数组等数据结构的不同优势进行选择。<br><strong>优点</strong>：有序数组的优势在于二分查找，链表的优势在于数据项的插入和数据项的删除。<br><strong>缺点</strong>：在有序数组中插入数据就会很慢，同样在链表中查找数据项效率就很低。<br><strong>综合</strong>：二叉树可以利用链表和有序数组的优势，同时可以合并有序数组和链表的优势，二叉树也是一种常用的数据结构。   </p><p>二叉树的构成： 二叉树由节点（node）和边组成。节点分为根节点、父节点、子节点。二叉树每个节点最多有两个叶子节点。  </p><h1><span id="完全二叉树">完全二叉树</span></h1><hr><p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p><h1><span id="二叉查找树bst">二叉查找树(BST)</span></h1><hr><p>Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）<br>普通二叉树的每个节点的左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。     </p><h1><span id="平衡二叉树">平衡二叉树</span></h1><hr><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>平衡二叉树（Balanced Binary Tree),又叫AVL树.<br>平衡二叉树是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树，所以说平衡二叉树首先是二叉查找树。<br>优点：这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)<br>缺点：但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。    </p><h2><span id="2-3查找树2-3-search-tree">2-3查找树(2-3 Search Tree)</span></h2><p>平衡二叉树每次插入元素之后维持树的平衡状态太昂贵。所以这里会介绍一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在<strong>对数的时间复杂度内</strong>完成。<br><a href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">2-3查找树</a></p><h1><span id="红黑树">红黑树</span></h1><p><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener"><br>最容易懂得红黑树</a><br><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">浅谈算法和数据结构: 九 平衡查找树之红黑树</a></p><h1><span id="b树b树b树">B树，B+树，B*树</span></h1><p>MySQL是基于B+树聚集索引组织表<br><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">B树，B+树，B*树</a></p><h2><span id="b树是一种多路搜索树并不一定是二叉的">B树是一种多路搜索树（并不一定是二叉的）</span></h2><p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。或者是空树，或者是满足特定性质的树。 </p><p><img src="/images/pasted-18.png" alt="upload successful"><br>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p><p>B-树的特性：  </p><ol><li>关键字集合<strong>分布在整颗树中</strong>；</li><li>任何一个关键字出现且<strong>只出现在一个结点中</strong>；</li><li>搜索<strong>有可能在非叶子结点结束</strong>；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；<h2><span id="b树">B+树</span></h2>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。<br>用途：<br>B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。<br>B+树是B-树的变体，也是一种多路搜索树。   <h3><span id="b树-vs-b树">B+树 VS B树</span></h3></li><li>有n棵子树的结点中含有n个关键字，<strong>每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点</strong>。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li><strong>所有的非终端结点可以看成是索引部分</strong>，结点中仅含其子树（根结点）中的最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li></ol><p><img src="/images/pasted-19.png" alt="upload successful"><br>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；    </p><p>B+的特性：</p><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；<h2><span id="b树">B*树</span></h2>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；  </li></ol><p><img src="/images/pasted-20.png" alt="upload successful"></p><h2><span id="小结">小结</span></h2><p>B-树：<br>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：<br>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p>B*树：<br>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p><h1><span id="lsm树">LSM树</span></h1><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。<br><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">[HBase] LSM树 VS B+树</a></p><h2><span id="复习b树">复习B+树</span></h2><p>比如Oracle的普通索引就是采用B+树的方式，下面是一个B+树的例子：   </p><p><img src="/images/pasted-21.png" alt="upload successful"><br>根节点和枝节点很简单，分别记录每个叶子节点的最小值(节点红色区域)，并用一个指针指向叶子节点(节点黄色区域)。E节点会存在多层多次，且每个节点分为红色和黄色两部分。   </p><p>叶子节点里每个键值都指向真正的数据块（如Oracle里的RowID），每个叶子节点都有前指针(节点红色区域)和后指针(节点红色区域)，这是为了做范围查询时，叶子节点间可以直接跳转，从而避免再去回溯至枝和跟节点。<br>缺点：<br>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。</p><p>对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</p><p>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）。</p><h2><span id="lsm树">LSM树</span></h2><p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p><p>为了更好的说明LSM树的原理，下面举个比较极端的例子：</p><p>现在假设有1000个节点的随机key，对于磁盘来说，肯定是把这1000个节点顺序写入磁盘最快，但是这样一来，读就悲剧了，因为key在磁盘中完全无序，每次读取都要全扫描；</p><p>那么，为了让读性能尽量高，数据在磁盘中必须得有序，这就是B+树的原理，但是写就悲剧了，因为会产生大量的随机IO，磁盘寻道速度跟不上。</p><p>LSM树本质上就是在读写之间取得平衡，和B+树相比，它牺牲了部分读性能，用来大幅提高写性能。</p><p>它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历所有的小树，但在每颗小树内部数据是有序的。</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><h2><span id="lsm在hbase中的使用">LSM在HBase中的使用</span></h2><p>以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。</p><ol><li>首先说说为什么要有WAL（Write Ahead Log），很简单，因为数据是先写到内存中，如果断电，内存中的数据会丢失，因此为了保护内存中的数据，需要在磁盘上先记录logfile，当内存中的数据flush到磁盘上时，就可以抛弃相应的Logfile。</li><li>什么是memstore, storefile？很简单，上面说过，LSM树就是一堆小树，在内存中的小树即memstore，每次flush，内存中的memstore变成磁盘上一个新的storefile。</li><li>为什么会有compact？很简单，随着小树越来越多，读的性能会越来越差，因此需要在适当的时候，对磁盘中的小树进行merge，多棵小树变成一颗大树。</li></ol><p><a href="https://blog.csdn.net/u014774781/article/details/52105708" target="_blank" rel="noopener">LSM树（Log-Structured Merge Tree）存储引擎</a><br>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。<br>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。<br>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。    </p><p>参考：<br><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#%E6%A0%91" target="_blank" rel="noopener">后端架构师技术图谱</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid Storage 原理二</title>
      <link href="/2019/04/25/Druid-Storage-%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
      <url>/2019/04/25/Druid-Storage-%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#segment生成过程">Segment生成过程</a></li><li><a href="#segment-load过程">Segment load过程</a></li><li><a href="#segment-query过程">Segment Query过程</a></li><li><a href="#druid的编码和压缩">Druid的编码和压缩</a></li></ul><!-- tocstop --><h1><span id="segment生成过程">Segment生成过程</span></h1><hr><ol><li>Add Row to Map</li><li>Begin persist to disk</li><li>Write version file</li><li>Merge and write dimension dict</li><li>Write time column</li><li>Write metric column</li><li>Write dimension column</li><li>Write index.drd</li><li>Merge and write bitmaps</li><li>Write metadata.drd<h1><span id="segment-load过程">Segment load过程</span></h1></li></ol><hr><p><img src="/images/pasted-17.png" alt="upload successful"></p><ol><li>Read version</li><li>Load segment to MappedByteBuffer</li><li>Get column offset from meta</li><li>Deserialize each column from ByteBuffer</li></ol><h1><span id="segment-query过程">Segment Query过程</span></h1><hr><p>Druid查询的最小单位是Segment，Segment在查询之前必须先load到内存，load过程如上一步所述。如果没有索引的话，我们的查询过程就只能Scan的，遇到符合条件的行选择出来，但是所有查询都进行全表Scan肯定是不可行的，所以我们需要索引来快速过滤不需要的行。Druid的Segmenet查询过程如下：</p><ol><li>构造1个Cursor进行迭代</li><li>查询之前构造出Fliter</li><li>根据Index匹配Fliter，得到满足条件的Row的Offset</li><li>根据每列的ColumnSelector去指定Row读取需要的列。<h1><span id="druid的编码和压缩">Druid的编码和压缩</span></h1></li></ol><hr><p>前面已经提到了，Druid对Long型的指标进行了差分编码和Table编码，Long型和Float型的指标进行了LZ4或者LZF压缩。</p><p>其实编码和压缩本质上是一个东西，一切熵增的编码都是压缩。 在计算机领域，我们一般把针对特定类型的编码称之为编码，针对任意类型的通用编码称之为压缩。</p><p>编码和压缩的本质就是让每一个bit尽可能带有更多的信息。</p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid Storage 原理一</title>
      <link href="/2019/04/25/Druid-Storage-%E5%8E%9F%E7%90%86/"/>
      <url>/2019/04/25/Druid-Storage-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#what-is-druid">What is Druid</a></li><li><a href="#druid架构">Druid架构</a><ul><li><a href="#节点分类">节点分类</a><ul><li><a href="#druid">druid</a><ul><li><a href="#coordinator-nodes">Coordinator Nodes</a></li><li><a href="#overlord">Overlord？？</a></li><li><a href="#broker">Broker</a></li><li><a href="#router">Router？？</a></li><li><a href="#historical">Historical</a></li><li><a href="#middlemanager">MiddleManager？？？</a></li><li><a href="#real-time-node">Real-time Node</a></li></ul></li><li><a href="#辅助">辅助</a><ul><li><a href="#zookeeper">Zookeeper</a></li><li><a href="#metadata-storage">Metadata Storage</a></li><li><a href="#deep-storage">Deep Storage</a></li></ul></li></ul></li><li><a href="#数据">数据</a><ul><li><a href="#column">Column</a></li><li><a href="#segment">Segment</a><ul><li><a href="#segment的存储格式">Segment的存储格式</a><ul><li><a href="#descriptorjson">descriptor.json</a></li><li><a href="#indexzip">index.zip</a><ul><li><a href="#versionbin">version.bin</a></li><li><a href="#metasmooth">meta.smooth</a></li><li><a href="#xxxxxsmoosh文件">xxxxx.smoosh文件</a></li><li><a href="#指标列的存储格式">指标列的存储格式</a></li><li><a href="#维度列的存储格式">维度列的存储格式</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="what-is-druid">What is Druid</span></h1><hr><p>Druid是一个开源的实时OLAP系统，可以对超大规模数据提供亚秒级查询，其具有以下特点：    </p><ol><li>列式存储</li><li>倒排索引 （<strong>基于Bitmap实现</strong>）</li><li>分布式的Shared-Nothing架构 （高可用，易扩展是Druid的设计目标）</li><li>实时摄入 （数据被Druid实时摄入后便可以立即查询）<h1><span id="druid架构">Druid架构</span></h1></li></ol><hr><ol><li>实时摄入的过程： 实时数据会首先按行摄入Real-time Nodes，Real-time Nodes会①先将每行的数据加入到1个map中，等达到一定的行数或者大小限制时，②Real-time Nodes 就会将内存中的map 持久化到磁盘中，③Real-time Nodes 会按照segmentGranularity将一定时间段内的小文件merge为一个大文件，生成Segment，④然后将Segment上传到Deep Storage（HDFS，S3）中，⑤Coordinator知道有Segment生成后，会通知相应的Historical Node下载对应的Segment，并负责该Segment的查询。</li><li>离线摄入的过程： 离线摄入的过程比较简单，就是直接通过MR job 生成Segment，剩下的逻辑和实时摄入相同：</li><li>用户查询过程： 用户的查询都是直接发送到Broker Node，Broker Node会将查询分发到Real-time节点和Historical节点，然后将结果合并后返回给用户。</li></ol><p><img src="/images/pasted-7.png" alt="upload successful"></p><h2><span id="节点分类">节点分类</span></h2><p><strong>Master</strong>:  <strong>Coordinator</strong> and <strong>Overlord</strong> processes, manages data availability and ingestion.<br><strong>Query</strong>: Runs <strong>Broker</strong> and optional <strong>Router</strong> processes, handles queries from external clients.<br><strong>Data</strong>: Runs <strong>Historical</strong> and <strong>MiddleManager</strong> processes, executes ingestion workloads and stores all queryable data.</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><h3><span id="druid">druid</span></h3><h4><span id="coordinator-nodes">Coordinator Nodes</span></h4><p>Coordinator 节点主要负责Segment的管理。Coordinator 节点会通知Historical节点加载新Segment，删除旧Segment，复制Segment，以及Segment间的复杂均衡。</p><p>Coordinator 节点依赖ZK确定Historical的存活和集群Segment的分布。</p><h4><span id="overlord">Overlord？？</span></h4><h4><span id="broker">Broker</span></h4><p>Broker 节点是Druid查询的入口，主要负责查询的分发和Merge。 之外，Broker还会对不可变的Segment的查询结果进行LRU缓存。</p><h4><span id="router">Router？？</span></h4><h4><span id="historical">Historical</span></h4><p>Historical 节点是整个Druid集群的骨干，主要负责加载不可变的segment，并负责Segment的查询（注意，<strong>Segment必须加载到Historical 的内存中才可以提供查询</strong>）。Historical 节点是无状态的，所以可以轻易的横向扩展和快速恢复。Historical 节点load和un-load segment是依赖ZK的，但是即使ZK挂掉，Historical依然可以对已经加载的Segment提供查询，只是不能再load 新segment，drop旧segment。</p><h4><span id="middlemanager">MiddleManager？？？</span></h4><h4><span id="real-time-node">Real-time Node</span></h4><p>实时节点主要负责数据的实时摄入，实时数据的查询，将实时数据转为Segment，将Segment Hand off 给Historical 节点。</p><h3><span id="辅助">辅助</span></h3><h4><span id="zookeeper">Zookeeper</span></h4><p>Druid依赖ZK实现服务发现，数据拓扑的感知，以及Coordinator的选主。</p><h4><span id="metadata-storage">Metadata Storage</span></h4><p>Metadata storage（Mysql） 主要用来存储 Segment和配置的元数据。当有新Segment生成时，就会将Segment的元信息写入metadata store, Coordinator 节点会监控Metadata store 从而知道何时load新Segment，何时drop旧Segment。注意，查询时不会涉及Metadata store。</p><h4><span id="deep-storage">Deep Storage</span></h4><p>Deep storage (S3 and HDFS)是作为Segment的永久备份，查询时同样不会涉及Deep storage。</p><h2><span id="数据">数据</span></h2><h3><span id="column">Column</span></h3><p><img src="/images/pasted-9.png" alt="upload successful"><br>Druid中的列主要分为3类：时间列，维度列，指标列。Druid在数据摄入和查询时都依赖时间列，这也是合理的，因为多维分析一般都带有时间维度。    </p><blockquote><p>维度和指标是OLAP系统中常见的概念，维度主要是事件的属性，在查询时一般用来filtering 和 group by，指标是用来聚合和计算的，一般是数值类型，像count,sum，min，max等。</p></blockquote><p>Druid中的维度列支持String，Long，Float，不过只有String类型支持倒排索引；指标列支持Long，Float，Complex， 其中Complex指标包含HyperUnique，Cardinality，Histogram，Sketch等复杂指标。强类型的好处是可以更好的对每1列进行编码和压缩， 也可以保证数据索引的高效性和查询性能。</p><h3><span id="segment">Segment</span></h3><p>前面提到过，Druid中会按时间段生成不可变的带倒排索引的列式文件，这个文件就称之为Segment，Segment是Druid中数据存储、复制、均衡、以及计算的基本单元， <strong>Segment由dataSource_beginTime_endTime_version_shardNumber唯一标识，1个segment一般包含5–10 million行记录，大小一般在300~700mb。</strong>    </p><h4><span id="segment的存储格式">Segment的存储格式</span></h4><p><img src="/images/pasted-12.png" alt="upload successful"><br>上图中给出了Segments在HDFS上的物理存储路径。我们可以看到Segment的路径格式为<code>/druid/segments/&lt;dataSource&gt;/&lt;intervalStart&gt;_&lt;intervalEnd&gt;/&lt;segmentGenerateTime&gt;/&lt;shardNum&gt;/</code><br>该目录下包括两个文件：</p><ol><li>descriptor.json</li><li>index.zip</li></ol><p>其中：</p><h5><span id="descriptorjson">descriptor.json</span></h5><p>是这个Segment的描述文件，其内容也保存在Druid集群的元数据的druid_segments表中。其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;dataSource&quot;: &quot;AD_active_user&quot;,</span><br><span class="line">&quot;interval&quot;: &quot;2018-04-01T00:00:00.000+08:00/2018-04-02T00:00:00.000+08:00&quot;,</span><br><span class="line">&quot;version&quot;: &quot;2018-04-01T00:04:07.022+08:00&quot;,</span><br><span class="line">&quot;loadSpec&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;hdfs&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/druid/segments/AD_active_user/20180401T000000.000+0800_20180402T000000.000+0800/2018-04-01T00_04_07.022+08_00/1/index.zip&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dimensions&quot;: &quot;appkey,spreadid,pkgid&quot;,</span><br><span class="line">&quot;metrics&quot;: &quot;myMetrics,count,offsetHyperLogLog&quot;,</span><br><span class="line">&quot;shardSpec&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;numbered&quot;,</span><br><span class="line">&quot;partitionNum&quot;: 1,</span><br><span class="line">&quot;partitions&quot;: 0</span><br><span class="line">&#125;,</span><br><span class="line">&quot;binaryVersion&quot;: 9,</span><br><span class="line">&quot;size&quot;: 168627,</span><br><span class="line">&quot;identifier&quot;: &quot;AD_active_user_2018-04-01T00:00:00.000+08:00_2018-04-02T00:00:00.000+08:00_2018-04-01T00:04:07.022+08:00_1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5><span id="indexzip">index.zip</span></h5><p>文件中包括了该segment中的数据。它包含了以下三类文件：</p><pre><code>* version.bin文件* meta.smooth文件* 数据文件(xxxxx.smoosh文件)</code></pre><h6><span id="versionbin">version.bin</span></h6><p>Segment内部标识的版本号，标识为v9. 内容为00000009</p><h6><span id="metasmooth">meta.smooth</span></h6><p>文件主要包含每1列的文件名和文件的偏移量。<br><img src="/images/pasted-13.png" alt="upload successful"></p><h6><span id="xxxxxsmoosh文件">xxxxx.smoosh文件</span></h6><p><img src="/images/pasted-10.png" alt="upload successful"><br>(D1、D2表示列)</p><blockquote><p>（注，druid为了减少文件描述符，将1个segment的所有列都合并到1个大的smoosh中，由于druid访问segment文件的时候采用MMap的方式，所以单个smoosh文件的大小不能超过2G，如果超过2G，就会写到下一个smoosh文件）。</p></blockquote><p><strong>在smoosh文件中，数据是按列存储中，包含时间列，维度列和指标列，其中每1列会包含2部分：ColumnDescriptor和binary数据</strong>。其中ColumnDescriptor主要保存每1列的数据类型和Serde的方式。<br>    smoosh文件中还有index.drd文件和metadata.drd文件，<strong>①</strong>其中index.drd主要包含该segment有哪些列，哪些维度，该Segment的时间范围以及使用哪种bitmap；<strong>②</strong>metadata.drd主要包含是否需要聚合，指标的聚合函数，查询粒度，时间戳字段的配置等。<br> xxxxx从0开始编号，最大为2G，是为了满足Java内存文件映射MapperByteBuffer限制.<br> 在segment生成阶段，Druid会为每列数据生成对应的索引，并将压缩后的聚合数据以及索引存入到以列命名的drd文件中(比如上segment的__time.drd,index.drd,appkey.drd…)。所有的<em>drd文件最终被合并成</em>.smoosh文件。其中压缩编码后的每列原始数据包含两部分<br>  使用Jackson序列化的ColumnDescriptor，包含列数据的元信息，比如数据的类型，是否包含multi-value。。。<br>其余部分为编码以后的二进制数据。</p><h6><span id="指标列的存储格式">指标列的存储格式</span></h6><p>指标列在xxxxx.smoosh文件中。<br>指标列的存储格式如上图所示：<br><img src="/images/pasted-14.png" alt="upload successful"></p><ol><li>version</li><li>value个数</li><li>每个block的value的个数（druid对Long和Float类型会按block进行压缩，block的大小是64K）</li><li>压缩类型 （druid目前主要有LZ4和LZF俩种压缩算法）</li><li>编码类型 （druid对Long类型支持差分编码和Table编码两种方式，Table编码就是将long值映射到int，当指标列的基数小于256时，druid会选择Table编码，否则会选择差分编码）</li><li>编码的header （以差分编码为例，header中会记录版本号，base value，每个value用几个bit表示）</li><li>每个block的header （主要记录版本号，是否允许反向查找，value的数量，列名长度和列名）</li><li>每1列具体的值</li></ol><p><img src="/images/pasted-15.png" alt="upload successful"></p><h6><span id="维度列的存储格式">维度列的存储格式</span></h6><p><img src="/images/pasted-16.png" alt="upload successful"><br>维度列在xxxxx.smoosh文件中。<br>String维度的存储格式如上图所示，前面提到过，时间列，维度列，指标列由两部分组成：ColumnDescriptor和binary数据。 String维度的binary数据主要由3部分组成：dict，字典编码后的id数组，用于倒排索引的bitmap。</p><p>以上图中的D2维度列为例，总共有4行，前3行的值是meituan，第4行的值是dianing。Druid中dict的实现十分简单，就是一个hashmap。图中dict的内容就是将meituan编码为0，dianping编码为1。 Id数组的内容就是用编码后的ID替换掉原始值，所以就是[1,1,1,0]。第3部分的倒排索引就是用bitmap表示某个值是否出现在某行中，如果出现了，bitmap对应的位置就会置为1，如图：meituan在前3行中都有出现，所以倒排索引1：[1,1,1,0]就表示meituan在前3行中出现。</p><p>显然，倒排索引的大小是列的基数*总的行数，如果没有处理的话结果必然会很大。不过好在如果维度列如果基数很高的话，bitmap就会比较稀疏，而稀疏的bitmap可以进行高效的压缩。</p><p>参考：<br><a href="https://blog.bcmeng.com/post/druid-storage.html#string-%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">https://blog.bcmeng.com/post/druid-storage.html#string-%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F</a><br><a href="http://druid.io/docs/0.14.0-incubating/design/index.html" target="_blank" rel="noopener">http://druid.io/docs/0.14.0-incubating/design/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid流式数据摄入</title>
      <link href="/2019/04/24/druid%E6%95%B0%E6%8D%AE%E6%91%84%E5%85%A5/"/>
      <url>/2019/04/24/druid%E6%95%B0%E6%8D%AE%E6%91%84%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#实时数据摄入">实时数据摄入</a><ul><li><a href="#pull">pull</a></li><li><a href="#push">push</a></li></ul></li></ul><!-- tocstop --><p>对于流式数据的摄入，Druid提供了两种方式，分别是push和pull</p><ol><li>pull:需要启动一个实时节点，通过不同的firehose摄入不同的流式数据，firehose可以被认为Druid接入不同数据源的适配器。</li><li>push:需要启动Tranquility或是Kafka索引服务。通过HTTP调用的方式进行数据摄入   </li></ol><p>离线数据摄入:可以通过Realtime节点摄入，也可以通过索引节点启动任务摄入</p><h1><span id="实时数据摄入">实时数据摄入</span></h1><p><a href="http://druid.io/docs/latest/ingestion/stream-ingestion.html" target="_blank" rel="noopener">官网Loading Streams</a></p><h2><span id="pull">pull</span></h2><p>由于Realtime Node 没有提供高可用，可伸缩等特性<br><del>可以认为已废弃</del><br>高版本中提供新的pull方式即<strong>Kafka Indexing Service (Stream Pull)</strong><br><a href="http://druid.io/docs/latest/tutorials/tutorial-kafka.html" target="_blank" rel="noopener">官网Kafka-indexing-service_1</a><br><a href="http://druid.io/docs/latest/development/extensions-core/kafka-ingestion.html" target="_blank" rel="noopener">官网Kafka-indexing-service_2</a></p><h2><span id="push">push</span></h2><p>Tranquility 是一个Scala库，它通过索引服务实现数据实时的摄入。它之所以存在，是因为Indexing service API属于低层面的。Tranquility是对索引服务进行抽象封装， <strong>对使用者屏蔽了 创建任务，处理分区、复制、服务发现和shema rollover等环节</strong>。<br>通过Tranquility 的数据摄入，可以分为两种方式</p><pre><code>1. Tranquility Server：发送方可以通过Tranquility Server 提供的HTTP接口，向Druid发送数据。 </code></pre><p>  <a href="http://druid.io/docs/latest/tutorials/tutorial-tranquility.html" target="_blank" rel="noopener">官网demo</a></p><pre><code>2. Tranquility Kafka：发送方可以先将数据发送到Kafka,Tranquility Kafka会根据配置从Kafka获取数据，并写到Druid中。  </code></pre><p>  <a href="http://druid.io/docs/latest/ingestion/stream-push.html" target="_blank" rel="noopener">官网demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/hadoop/druid/apache-druid-0.14.0-incubating</span><br><span class="line">ll ./conf/tranquility/server.json</span><br><span class="line">ll ./conf/tranquility/kafka.json</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://druid.io/docs/latest/tutorials/tutorial-kafka.html" target="_blank" rel="noopener">http://druid.io/docs/latest/tutorials/tutorial-kafka.html</a><br><a href="http://druid.io/docs/latest/ingestion/stream-ingestion.html" target="_blank" rel="noopener">http://druid.io/docs/latest/ingestion/stream-ingestion.html</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid为什么要调时区</title>
      <link href="/2019/04/24/druid%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%97%B6%E5%8C%BA/"/>
      <url>/2019/04/24/druid%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%97%B6%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1><span id="utc时间ampgmt时间">UTC时间&amp;GMT时间</span></h1><hr><p>UTC时间是时间标准时间（Universal Time Coordinated），UTC是根据原子钟来计算时间，误差非常小。</p><p>UTC也是指零时区的时间，如果要表示其他时区的时间，这里要注意没有UTC+0800或者UTC+8这样的表示方式（至少Java里面没有，一般用于口头表示），只有Asia/Shanghai这样的表示方式，详细的时区列表参考这个文档时区列表﻿，不要问我为什么没有北京时区。。。</p><p>GMT时间是根据地球的自转和公转来计算时间，老的时间计量标准，这里我们不过多讨论</p><h1><span id="表达时间方式">表达时间方式</span></h1><hr><p>我们一般表示时间都会带格式以方便理解，例如时间表达式是’2018-09-12 08:00:00’，因为我们在东八区，所以默认是：北京时间2018年9月12号8点整。但是如果是一个美国人看到这个时间，就会认为是美国东部or西部时间的2018年9月12号8点整。所以从这种表达方式很不准确，因为没有指明到底是哪个时区的时间！！！！</p><p>所以准确的表达时间必须带有时区，例如2018-09-12 08:00:00+0800，表达了Asia/Shanghai这个时区的时间2018年9月12号8点整。这里要注意+0800并不是表示加8小时的意思，只是表示这个时间’2018-09-12 08:00:00’是东八区Asia/Shanghai的时间，仅此而已。</p><h1><span id="utc时间的时间戳">UTC时间的时间戳</span></h1><hr><p>讲清楚了时间表达方式，再讲时间戳。其实时间戳是没有时区概念的，或者说时间戳只能是0时区的。时间戳是从1970-01-11 00:00:00+0000开始的（原因大家都知道），也就是在’1970-01-11 00:00:00+0000’这个时间点，时间戳是0。再换句话说在’1970-01-11 08:00:00+0800’时间戳也是0。这也是Java里时间组件的默认方式，不管用户输入的人类可识别的时间是什么格式，在内部统一存的是时间戳。</p><p>例如时间是’2018-09-01 <strong>08</strong>:00:00+0800’，那么使用date.getTime()获取到时间戳是1535760000000；时间是’2018-09-01 <strong>00</strong>:00:00+0000’，获取到时间戳也是1535760000000。而两者的日期格式差了8小时，而只是时区不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ssZ&quot;);</span><br><span class="line">System.out.println(sdf.parse(&quot;2018-09-01 08:00:00+0800&quot;).getTime());</span><br><span class="line">System.out.println(sdf.parse(&quot;2018-09-01 00:00:00+0000&quot;).getTime());</span><br></pre></td></tr></table></figure></p><p><strong>时间戳只能是0时区的，所以8时区的时间如果不指定时区也会按照0时区来转化时间戳。此时将时间戳转化为日期格式自然就少了8小时</strong></p><p>可以观察到这2行代码的输出都是1535760000000，这就证明了上面的观点。再啰嗦2点：</p><ol><li>第一行代码DateFormat中Z表示时区，所以String类型格式时间带上+0800这种表达式，就能正确获取时间戳了。</li><li>SimpleDateFormat是线程不安全的，不要用</li></ol><h1><span id="时区设置">时区设置</span></h1><hr><p>为什么我们写以下代码的时候，程序能正确知道我们的时区呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(sdf2.parse(&quot;2018-09-01 08:00:00&quot;).getTime());</span><br></pre></td></tr></table></figure></p><p>因为我们在mac上设置了时区.<br>在Java中也可以设置时区</p><ol><li>启动设置<br><code>java -Duser.timezone=Asia/Shanghai -jar xxx.jar</code></li><li><p>代码中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeZone.setDefault(TimeZone.getTimeZone(&quot;UTC&quot;));</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(sdf.parse(&quot;2018-09-01 08:00:00&quot;).getTime());</span><br></pre></td></tr></table></figure></li><li><p>单次处理生效，建议使用joda的时间包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).withChronology(ISOChronology.getInstance(DateTimeZone.forID(&quot;Asia/Shanghai&quot;)));</span><br><span class="line">System.out.println(dateTimeFormatter.parseDateTime(&quot;2018-09-01 08:00:00&quot;).getMillis());</span><br></pre></td></tr></table></figure></li></ol><p>参考：<br><a href="https://www.cnblogs.com/oldtrafford/p/9680791.html" target="_blank" rel="noopener">https://www.cnblogs.com/oldtrafford/p/9680791.html</a></p>]]></content>
      
      
      <categories>
          
          <category> druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka问题集锦</title>
      <link href="/2019/04/24/kafka%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
      <url>/2019/04/24/kafka%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#kafka为什么要在topic里加入分区的概念">kafka为什么要在topic里加入分区的概念？</a></li><li><a href="#为什么有了partition还需要segment">为什么有了partition还需要segment</a></li></ul><!-- tocstop --><h1><span id="kafka为什么要在topic里加入分区的概念">kafka为什么要在topic里加入分区的概念？</span></h1><hr><p>topic是逻辑的概念，partition是物理的概念，对用户来说是透明的。</p><p>producer只需要关心消息发往哪个topic，而consumer只关心自己订阅哪个topic，并不关心每条消息存于整个集群的哪个broker。  为了性能考虑，如果topic内的消息只存于一个broker，那这个broker会成为瓶颈，无法做到水平扩展。</p><p>所以把topic内的数据分布到整个集群就是一个自然而然的设计方式。</p><p>Partition的引入就是解决水平扩展问题的一个方案。  </p><p>每个partition可以被认为是一个无限长度的数组，新数据顺序追加进这个数组。</p><p>物理上，每个partition对应于一个文件夹。一个broker上可以存放多个partition。</p><p>这样，producer可以将数据发送给多个broker上的多个partition，consumer也可以并行从多个broker上的不同paritition上读数据，实现了水平扩展.     </p><h1><span id="为什么有了partition还需要segment">为什么有了partition还需要segment</span></h1><hr><p>consume消费数据并不需要等到segment写满，只要有一条数据被commit，就可以立马被消费  </p><p>segment对应一个文件（实现上对应2个文件，一个数据文件，一个索引文件），一个partition对应一个文件夹，一个partition里理论上可以包含任意多个segment。</p><p>所以partition可以认为是在segment上做了一层包装。   </p><p>如果不引入segment，一个partition直接对应一个文件（应该说两个文件，一个数据文件，一个索引文件），那这个文件会一直增大。</p><p>同时，在做data purge时，需要把文件的前面部分给删除，不符合kafka对文件的顺序写优化设计方案。</p><p>引入segment后，每次做data purge，只需要把旧的segment整个文件删除即可，保证了每个segment的顺序写.</p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka的副本机制</title>
      <link href="/2019/04/24/kafka%E7%9A%84%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/24/kafka%E7%9A%84%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#分区和副本">分区和副本</a></li><li><a href="#副本分配算法">副本分配算法</a></li><li><a href="#kafka中的副本">kafka中的副本</a></li><li><a href="#isr集合中的副本必须满足的条件">ISR集合中的副本必须满足的条件</a></li><li><a href="#副本同步时的两个重要概念">副本同步时的两个重要概念</a></li><li><a href="#副本协同机制">副本协同机制</a><ul><li><a href="#第一次发送fetch请求">第一次发送fetch请求</a></li><li><a href="#第二次发送fetch请求">第二次发送fetch请求</a></li></ul></li></ul><!-- tocstop --><h1><span id="分区和副本">分区和副本</span></h1><p>partition的副本被称为replica，每个分区可以有多个副本，并且在副本集中会存在一个leader副本，所有的读写请求都会通过leader完成，follower复制<strong>只负责备份数据</strong>。</p><p>副本会均匀分配到多台broker上，当leader节点挂掉之后，会从副本集中重新选出一个副本作为leader继续提供服务</p><h1><span id="副本分配算法">副本分配算法</span></h1><ol><li>将所有N Broker和待分配的i个Partition排序.</li><li>将第i个Partition分配到第(i mod n)个Broker上.</li><li>将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.</li></ol><h1><span id="kafka中的副本">kafka中的副本</span></h1><hr><ol><li>leader副本：响应客户端的读写请求</li><li>follow副本：备份leader的数据，<strong>不进行读写操作</strong></li><li>ISR副本：leader副本和所有能够与leader副本保持基本同步的follow副本，如 果follow副本和leader副本数据同步速度过慢，该follow将会被T出ISR副本</li></ol><p>Leader副本处理分区的所有读写请求并维护自身以及Follower副本的状态。当Leader副本失效时，会从Follower副本中选举一个新的Leader副本对外提供读写服务。</p><h1><span id="isr集合中的副本必须满足的条件">ISR集合中的副本必须满足的条件</span></h1><hr><ol><li>副本<strong>所在的节点</strong>与zk相连</li><li>副本的最后一条消息和leader副本的最后一条消息的差值不能超过阈值<code>replica.lag.time.max.ms</code>默认为10秒。如果该follower在此时间间隔之内没有追上leader,则该follower将会被踢出ISR   </li></ol><p>满足上面2个条件则认为该副本或者节点处于同步中（in sync）。Leader副本会追踪所有同步中的节点，一旦一个节点宕机或者落后太久，Leader就会将该节点从同步副本中ISR列表中移除。Follower从Leader副本同步数据，不是同步，也不是单纯的异步。而是采用了一个同步列表的方式来做了同步和异步的折中。</p><h1><span id="副本同步时的两个重要概念">副本同步时的两个重要概念</span></h1><hr><ol><li>LEO（Last end offset） <strong>记录了该副本底层日志中的下一条消息的offset</strong>，例如LEO为10，那么当前的offset为9</li><li>HW （High water）<strong>标记着可消费的消息</strong>，ISR列表中最小的LEO作为一个分区的HW。HW之前表示已经提交的消息，消费者只能消费已经提交的，HW之后的消息消费者不能消费，因为HW之后的消息表示还没有被ISR列表中的Follower同步；<br>对于同一个副本而言HW不会大于LEO，小于等于HW的消息将会被认为是已备份的。</li></ol><p><img src="/images/pasted-6.png" alt="upload successful"><br>也就是说消息写入到所有副本的日志中才算提交，才可以被消费者消费。<strong>这是对消费者来说的，生产者是否要等待消息都被写入所有副本之后才收到返回是另外一回事</strong>，这个可以通过acks来配置，kafka为生产者提供3种消息确认机制（request.required.acks参数）：</p><ol><li>acks=0，生产者无需等待代理返回确认，就是可以连续发送，但是无法保证消息是否被代理收到。</li><li>acks=1，生产者需要等待Leader副本以及成功写入日志。这种方式降级了消息丢失的可能性，但是也只是Leader写入日志而不管Follower是否写入。</li><li>acks=-1，Leader副本和所有Follower都写入日志才会向生产者发送确认信息。</li></ol><h1><span id="副本协同机制">副本协同机制</span></h1><hr><p><strong>producer将消息发送到该partition的leader上，leader会把消息写入其本地log，每个follower都从leader pull数据。在follower收到消息并且将消息写入本地log之后会向leader发送ack，一旦leader收到了ISR中所有replica的ACK，该消息就被认为已经commit了，leader会增加HW并向producer发送ACK</strong>  </p><h2><span id="第一次发送fetch请求">第一次发送fetch请求</span></h2><hr><p>follower发送fetch请求，并带上自己的LEO<br>leader端的操作 </p><ol><li>当producer发送一个消息给leader之后，leader会把消息写入磁盘 </li><li>然后leader会更新LEO，这时候尝试更新HW，<strong>HW是取LEO和remoteLEO的较小值</strong>，这时候HW依然为0.（<strong>remoteLEO取所有Follower发过来的offset中最小的一个</strong>） </li><li>把消息内容和当前的HW值发送给follower副本</li></ol><p>当收到响应之后，follower端的操作 </p><ol><li>将消息写入本地log，同时更新LEO </li><li>比较本地LEO和返回的HW,比较他们取小值赋值给HW</li></ol><h2><span id="第二次发送fetch请求">第二次发送fetch请求</span></h2><hr><p>leader </p><ol><li>更新remoteLEO=1 </li><li>更新HW为1 </li><li>把数据和当前HW返回给follower，如果这时候没有数据，则返回空</li></ol><p>follower收到response之后 </p><ol><li>如果有数据则写入本地日志，并且更新LEO </li><li>更新HW的值<br>到目前为止，consumer就可以消费offset=0的消息了</li></ol><p>原文：<a href="https://blog.csdn.net/qq_39907763/article/details/82697452" target="_blank" rel="noopener">https://blog.csdn.net/qq_39907763/article/details/82697452</a></p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka是靠什么机制保持高可靠，高可用的？</title>
      <link href="/2019/04/24/Kafka%E6%98%AF%E9%9D%A0%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8C%81%E9%AB%98%E5%8F%AF%E9%9D%A0%EF%BC%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F/"/>
      <url>/2019/04/24/Kafka%E6%98%AF%E9%9D%A0%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8C%81%E9%AB%98%E5%8F%AF%E9%9D%A0%EF%BC%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>这个问题等同于“说说 Acks 参数对消息持久化的影响？”，只是后者把问题描述的更明确</p><!-- toc --><ul><li><a href="#如何保证宕机的时候数据不丢失问题">如何保证宕机的时候数据不丢失？(问题)</a></li><li><a href="#多副本冗余的高可用机制">多副本冗余的高可用机制</a></li><li><a href="#多副本之间数据如何同步">多副本之间数据如何同步？</a></li><li><a href="#isr-到底指的是什么东西">ISR 到底指的是什么东西？</a></li><li><a href="#acks-参数的含义">Acks 参数的含义</a><ul><li><a href="#第一种选择是把-acks-参数设置为-0">第一种选择是把 Acks 参数设置为 0</a></li><li><a href="#第二种选择是设置-acks-1">第二种选择是设置 Acks = 1</a></li><li><a href="#最后一种情况就是设置-acksall">最后一种情况，就是设置 Acks=all</a></li></ul></li><li><a href="#最后的思考">最后的思考</a></li></ul><!-- tocstop --><h1><span id="如何保证宕机的时候数据不丢失问题">如何保证宕机的时候数据不丢失？(问题)</span></h1><hr><p>如果想理解这个 Acks 参数的含义，首先就得搞明白 Kafka 的高可用架构原理。</p><p>比如下面的图里就是表明了对于每一个 Topic，<strong>我们都可以设置它包含几个 Partition，每个 Partition 负责存储这个 Topic 一部分的数据</strong>。</p><p>然后 Kafka 的 Broker 集群中，每台机器上都存储了一些 Partition，也就存放了 Topic 的<strong>一部分数据</strong>，这样就实现了 Topic 的数据分布式存储在一个 Broker 集群上。</p><p><img src="/images/pasted-0.png" alt="upload successful"><br>但是有一个问题，万一一个 Kafka Broker 宕机了，此时上面存储的数据不就丢失了吗？</p><p>没错，这就是一个比较大的问题了，分布式系统的数据丢失问题，是它首先必须要解决的，一旦说任何一台机器宕机，此时就会导致数据的丢失。</p><h1><span id="多副本冗余的高可用机制">多副本冗余的高可用机制</span></h1><hr><p>所以如果大家去分析任何一个分布式系统的原理，比如说 Zookeeper、Kafka、Redis Cluster、Elasticsearch、HDFS，等等。</p><p>其实它们都有自己内部的一套多副本冗余的机制，多副本冗余几乎是现在任何一个优秀的分布式系统都一般要具备的功能。</p><p>在 Kafka 集群中，每个 Partition 都有多个副本，其中一个副本叫做 Leader，其他的副本叫做 Follower，如下图：</p><p><img src="/images/pasted-2.png" alt="upload successful"><br>如上图所示，假设一个 Topic 拆分为了 3 个 Partition，分别是 Partition0，Partiton1，Partition2，此时每个 Partition 都有 2 个副本。</p><p>比如 Partition0 有一个副本是 Leader，另外一个副本是 Follower，Leader 和 Follower 两个副本是分布在不同机器上的。</p><p>这样的多副本冗余机制，可以保证任何一台机器挂掉，都不会导致数据彻底丢失，因为起码还是有副本在别的机器上的。</p><h1><span id="多副本之间数据如何同步">多副本之间数据如何同步？</span></h1><hr><p>接着我们就来看看多个副本之间数据是如何同步的？其实任何一个 Partition，只有 Leader 是对外提供读写服务的。</p><p>也就是说，如果有一个客户端往一个 Partition 写入数据，此时一般就是写入这个 Partition 的 Leader 副本。</p><p>然后 Leader 副本接收到数据之后，Follower 副本会不停的给它发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。</p><p>如下图所示：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><h1><span id="isr-到底指的是什么东西">ISR 到底指的是什么东西？</span></h1><hr><p>既然大家已经知道了 Partiton 的多副本同步数据的机制了，那么就可以来看看 ISR 是什么了。</p><p>ISR 全称是“In-Sync Replicas”，也就是保持同步的副本，它的含义就是，跟 Leader 始终保持同步的 Follower 有哪些。</p><p>大家可以想一下 ，如果说某个 Follower 所在的 Broker 因为 JVM FullGC 之类的问题，导致自己卡顿了，无法及时从 Leader 拉取同步数据，那么是不是会导致 Follower 的数据比 Leader 要落后很多？</p><p>所以这个时候，就意味着 Follower 已经跟 Leader 不再处于同步的关系了。</p><p>但是只要 Follower 一直及时从 Leader 同步数据，就可以保证它们是处于同步的关系的。</p><p>所以每个 Partition 都有一个 ISR，这个 ISR 里一定会有 Leader 自己，因为 Leader 肯定数据是最新的，然后就是那些跟 Leader 保持同步的 Follower，也会在 ISR 里。</p><h1><span id="acks-参数的含义">Acks 参数的含义</span></h1><p>铺垫了那么多的东西，最后终于可以进入主题来聊一下 Acks 参数的含义了。</p><p>如果大家没看明白前面的那些副本机制、同步机制、ISR 机制，那么就无法充分的理解 Acks 参数的含义，这个参数实际上决定了很多重要的东西。</p><p><strong>首先这个 Acks 参数，是在 Kafka Producer，也就是生产者客户端里设置的</strong>。</p><p>也就是说，你往 Kafka 写数据的时候，就可以来设置这个 Acks 参数。然后这个参数实际上有三种常见的值可以设置，分别是：0、1 和 all。</p><h2><span id="第一种选择是把-acks-参数设置为-0">第一种选择是把 Acks 参数设置为 0</span></h2><p>意思就是我的 Kafka Producer 在客户端，只要把消息发送出去，不管那条数据有没有在哪怕 Partition Leader 上落到磁盘，我就不管它了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。</p><p>结果呢，Partition Leader 所在 Broker 就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会导致这条消息就丢失了。</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2><span id="第二种选择是设置-acks-1">第二种选择是设置 Acks = 1</span></h2><p>意思就是说只要 Partition Leader 接收到消息而且写入本地磁盘了，就认为成功了，不管它其他的 Follower 有没有同步过去这条消息了。</p><p>这种设置其实是 Kafka 默认的设置，大家请注意，<strong>划重点！这是默认的设置</strong>。</p><p>也就是说，默认情况下，你要是不管 Acks 这个参数，只要 Partition Leader 写成功就算成功。</p><p>但是这里有一个问题，万一 Partition Leader 刚刚接收到消息，Follower 还没来得及同步过去，结果 Leader 所在的 Broker 宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><h2><span id="最后一种情况就是设置-acksall">最后一种情况，就是设置 Acks=all</span></h2><p>这个意思就是说，Partition Leader 接收到消息之后，还必须要求 ISR 列表里跟 Leader 保持同步的那些 Follower 都要把消息同步过去，才能认为这条消息是写入成功了。</p><p>如果说 Partition Leader 刚接收到了消息，但是结果 Follower 没有收到消息，此时 Leader 宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能 Partition2 的 Follower 变成 Leader 了，此时 ISR 列表里只有最新的这个 Follower 转变成的 Leader 了，那么只要这个新的 Leader 接收消息就算成功了。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><h1><span id="最后的思考">最后的思考</span></h1><p>Acks=all 就可以代表数据一定不会丢失了吗？当然不是，如果你的 Partition 只有一个副本，也就是一个 Leader，任何 Follower 都没有，你认为 acks=all 有用吗？</p><p>当然没用了，因为 ISR 里就一个 Leader，它接收完消息后宕机，也会导致数据丢失。</p><p>所以说，这个 Acks=all，必须跟 ISR 列表里<strong>至少有 2 个以上的副本配合使用，起码是有一个 Leader 和一个 Follower 才可以</strong>。</p><p>这样才能保证说写一条数据过去，一定是 2 个以上的副本都收到了才算是成功，此时任何一个副本宕机，不会导致数据丢失。</p><p>所以希望大家把这篇文章好好理解一下，对大家出去面试，或者工作中用 Kafka 都是很好的一个帮助。</p><p>参考：<br><a href="https://mp.weixin.qq.com/s/9vIy6R8IMRU2KoIMzhHHhw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9vIy6R8IMRU2KoIMzhHHhw</a></p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404.html</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[<!DOCTYPE HTML><html><head><meta name="generator" content="Hexo 3.8.0">  <meta http-equiv="content-type" content="text/html;charset=utf-8;">  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">  <meta name="robots" content="all">  <meta name="robots" content="index,follow">  <link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"></head><body>  <script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="/" homepagename="回到我的主页">  </script>  <script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"></script>  <script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"></script></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
